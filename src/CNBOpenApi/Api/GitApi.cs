// <auto-generated>
/*
 * CNB OPENAPI
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: cnb@tencent.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using CNBOpenApi.Client;
using CNBOpenApi.Model;
using System.Diagnostics.CodeAnalysis;

namespace CNBOpenApi.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IGitApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        GitApiEvents Events { get; }

        /// <summary>
        /// 创建一个 blob
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="postBlobForm">PostBlobForm</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBlobApiResponse"/>&gt;</returns>
        Task<ICreateBlobApiResponse> CreateBlobAsync(string repo, ApiPostBlobForm postBlobForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 创建一个 blob
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="postBlobForm">PostBlobForm</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBlobApiResponse"/>?&gt;</returns>
        Task<ICreateBlobApiResponse?> CreateBlobOrDefaultAsync(string repo, ApiPostBlobForm postBlobForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 创建新分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="createBranchForm">Create BranchDetail Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBranchApiResponse"/>&gt;</returns>
        Task<ICreateBranchApiResponse> CreateBranchAsync(string repo, OpenapiCreateBranchForm createBranchForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 创建新分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="createBranchForm">Create BranchDetail Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBranchApiResponse"/>?&gt;</returns>
        Task<ICreateBranchApiResponse?> CreateBranchOrDefaultAsync(string repo, OpenapiCreateBranchForm createBranchForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 创建一个 tag
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="postTagForm">PostTagFrom</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTagApiResponse"/>&gt;</returns>
        Task<ICreateTagApiResponse> CreateTagAsync(string repo, ApiPostTagFrom postTagForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 创建一个 tag
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="postTagForm">PostTagFrom</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTagApiResponse"/>?&gt;</returns>
        Task<ICreateTagApiResponse?> CreateTagOrDefaultAsync(string repo, ApiPostTagFrom postTagForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBranchApiResponse"/>&gt;</returns>
        Task<IDeleteBranchApiResponse> DeleteBranchAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBranchApiResponse"/>?&gt;</returns>
        Task<IDeleteBranchApiResponse?> DeleteBranchOrDefaultAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="key">commit annotation key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAnnotationApiResponse"/>&gt;</returns>
        Task<IDeleteCommitAnnotationApiResponse> DeleteCommitAnnotationAsync(string repo, string sha, string key, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="key">commit annotation key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAnnotationApiResponse"/>?&gt;</returns>
        Task<IDeleteCommitAnnotationApiResponse?> DeleteCommitAnnotationOrDefaultAsync(string repo, string sha, string key, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定 commit 的附件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="assetId">asset id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAssetApiResponse"/>&gt;</returns>
        Task<IDeleteCommitAssetApiResponse> DeleteCommitAssetAsync(string repo, string sha1, int assetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定 commit 的附件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="assetId">asset id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAssetApiResponse"/>?&gt;</returns>
        Task<IDeleteCommitAssetApiResponse?> DeleteCommitAssetOrDefaultAsync(string repo, string sha1, int assetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定标签
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagApiResponse"/>&gt;</returns>
        Task<IDeleteTagApiResponse> DeleteTagAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定标签
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagApiResponse"/>?&gt;</returns>
        Task<IDeleteTagApiResponse?> DeleteTagOrDefaultAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定 tag 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tagWithKey">tag with key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagAnnotationApiResponse"/>&gt;</returns>
        Task<IDeleteTagAnnotationApiResponse> DeleteTagAnnotationAsync(string repo, string tagWithKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 删除指定 tag 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="tagWithKey">tag with key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagAnnotationApiResponse"/>?&gt;</returns>
        Task<IDeleteTagAnnotationApiResponse?> DeleteTagAnnotationOrDefaultAsync(string repo, string tagWithKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 打包下载 commit 变更文件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">commit sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCommitChangedFilesApiResponse"/>&gt;</returns>
        Task<IGetArchiveCommitChangedFilesApiResponse> GetArchiveCommitChangedFilesAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 打包下载 commit 变更文件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha1">commit sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCommitChangedFilesApiResponse"/>?&gt;</returns>
        Task<IGetArchiveCommitChangedFilesApiResponse?> GetArchiveCommitChangedFilesOrDefaultAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 打包下载两次 ref 之间的变更文件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCompareChangedFilesApiResponse"/>&gt;</returns>
        Task<IGetArchiveCompareChangedFilesApiResponse> GetArchiveCompareChangedFilesAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 打包下载两次 ref 之间的变更文件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCompareChangedFilesApiResponse"/>?&gt;</returns>
        Task<IGetArchiveCompareChangedFilesApiResponse?> GetArchiveCompareChangedFilesOrDefaultAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBranchApiResponse"/>&gt;</returns>
        Task<IGetBranchApiResponse> GetBranchAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBranchApiResponse"/>?&gt;</returns>
        Task<IGetBranchApiResponse?> GetBranchOrDefaultAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="varRef">ref</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitApiResponse"/>&gt;</returns>
        Task<IGetCommitApiResponse> GetCommitAsync(string repo, string varRef, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="varRef">ref</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitApiResponse"/>?&gt;</returns>
        Task<IGetCommitApiResponse?> GetCommitOrDefaultAsync(string repo, string varRef, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsApiResponse"/>&gt;</returns>
        Task<IGetCommitAnnotationsApiResponse> GetCommitAnnotationsAsync(string repo, string sha, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsApiResponse"/>?&gt;</returns>
        Task<IGetCommitAnnotationsApiResponse?> GetCommitAnnotationsOrDefaultAsync(string repo, string sha, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="getCommitAnnotationsForm">Get Commit Annotations In Batch Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsInBatchApiResponse"/>&gt;</returns>
        Task<IGetCommitAnnotationsInBatchApiResponse> GetCommitAnnotationsInBatchAsync(string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="getCommitAnnotationsForm">Get Commit Annotations In Batch Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsInBatchApiResponse"/>?&gt;</returns>
        Task<IGetCommitAnnotationsInBatchApiResponse?> GetCommitAnnotationsInBatchOrDefaultAsync(string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的附件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsByShaApiResponse"/>&gt;</returns>
        Task<IGetCommitAssetsByShaApiResponse> GetCommitAssetsByShaAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的附件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsByShaApiResponse"/>?&gt;</returns>
        Task<IGetCommitAssetsByShaApiResponse?> GetCommitAssetsByShaOrDefaultAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的 check statuses
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="commitish">commitish</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitStatusesApiResponse"/>&gt;</returns>
        Task<IGetCommitStatusesApiResponse> GetCommitStatusesAsync(string repo, string commitish, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 commit 的 check statuses
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="commitish">commitish</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitStatusesApiResponse"/>?&gt;</returns>
        Task<IGetCommitStatusesApiResponse?> GetCommitStatusesOrDefaultAsync(string repo, string commitish, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 对比 base...head
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCompareCommitsApiResponse"/>&gt;</returns>
        Task<IGetCompareCommitsApiResponse> GetCompareCommitsAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 对比 base...head
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCompareCommitsApiResponse"/>?&gt;</returns>
        Task<IGetCompareCommitsApiResponse?> GetCompareCommitsOrDefaultAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询仓库文件列表或文件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="filePath">path</param>
        /// <param name="varRef">ref (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetContentApiResponse"/>&gt;</returns>
        Task<IGetContentApiResponse> GetContentAsync(string repo, string filePath, Option<string> varRef = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询仓库文件列表或文件
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="filePath">path</param>
        /// <param name="varRef">ref (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetContentApiResponse"/>?&gt;</returns>
        Task<IGetContentApiResponse?> GetContentOrDefaultAsync(string repo, string filePath, Option<string> varRef = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 获取仓库默认分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHeadApiResponse"/>&gt;</returns>
        Task<IGetHeadApiResponse> GetHeadAsync(string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 获取仓库默认分支
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHeadApiResponse"/>?&gt;</returns>
        Task<IGetHeadApiResponse?> GetHeadOrDefaultAsync(string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 Tag
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>&gt;</returns>
        Task<IGetTagApiResponse> GetTagAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 Tag
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>?&gt;</returns>
        Task<IGetTagApiResponse?> GetTagOrDefaultAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 tag 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagAnnotationsApiResponse"/>&gt;</returns>
        Task<IGetTagAnnotationsApiResponse> GetTagAnnotationsAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定 tag 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagAnnotationsApiResponse"/>?&gt;</returns>
        Task<IGetTagAnnotationsApiResponse?> GetTagAnnotationsOrDefaultAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询分支列表
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBranchesApiResponse"/>&gt;</returns>
        Task<IListBranchesApiResponse> ListBranchesAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询分支列表
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBranchesApiResponse"/>?&gt;</returns>
        Task<IListBranchesApiResponse?> ListBranchesOrDefaultAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询 commit 列表
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">sha or branch (optional)</param>
        /// <param name="author">commit author pattern (optional)</param>
        /// <param name="committer">commit committer pattern (optional)</param>
        /// <param name="since">commit since (optional)</param>
        /// <param name="until">commit until (optional)</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCommitsApiResponse"/>&gt;</returns>
        Task<IListCommitsApiResponse> ListCommitsAsync(string repo, Option<string> sha = default, Option<string> author = default, Option<string> committer = default, Option<string> since = default, Option<string> until = default, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询 commit 列表
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha">sha or branch (optional)</param>
        /// <param name="author">commit author pattern (optional)</param>
        /// <param name="committer">commit committer pattern (optional)</param>
        /// <param name="since">commit since (optional)</param>
        /// <param name="until">commit until (optional)</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCommitsApiResponse"/>?&gt;</returns>
        Task<IListCommitsApiResponse?> ListCommitsOrDefaultAsync(string repo, Option<string> sha = default, Option<string> author = default, Option<string> committer = default, Option<string> since = default, Option<string> until = default, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询标签列表
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTagsApiResponse"/>&gt;</returns>
        Task<IListTagsApiResponse> ListTagsAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询标签列表
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTagsApiResponse"/>?&gt;</returns>
        Task<IListTagsApiResponse?> ListTagsOrDefaultAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 确认 Commit asset 上传完成
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="token">upload token</param>
        /// <param name="assetPath">release asset path</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadConfirmationApiResponse"/>&gt;</returns>
        Task<IPostCommitAssetUploadConfirmationApiResponse> PostCommitAssetUploadConfirmationAsync(string repo, int sha1, string token, string assetPath, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 确认 Commit asset 上传完成
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="token">upload token</param>
        /// <param name="assetPath">release asset path</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadConfirmationApiResponse"/>?&gt;</returns>
        Task<IPostCommitAssetUploadConfirmationApiResponse?> PostCommitAssetUploadConfirmationOrDefaultAsync(string repo, int sha1, string token, string assetPath, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 新增一个 Commit asset
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="createCommitAssetUploadUrlForm">Post Commit Asset Upload URL Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadURLApiResponse"/>&gt;</returns>
        Task<IPostCommitAssetUploadURLApiResponse> PostCommitAssetUploadURLAsync(string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 新增一个 Commit asset
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="createCommitAssetUploadUrlForm">Post Commit Asset Upload URL Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadURLApiResponse"/>?&gt;</returns>
        Task<IPostCommitAssetUploadURLApiResponse?> PostCommitAssetUploadURLOrDefaultAsync(string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 设定指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="putCommitAnnotationsForm">Put Commit Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutCommitAnnotationsApiResponse"/>&gt;</returns>
        Task<IPutCommitAnnotationsApiResponse> PutCommitAnnotationsAsync(string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 设定指定 commit 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="putCommitAnnotationsForm">Put Commit Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutCommitAnnotationsApiResponse"/>?&gt;</returns>
        Task<IPutCommitAnnotationsApiResponse?> PutCommitAnnotationsOrDefaultAsync(string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 设定指定 tag 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="putTagAnnotationsForm">Put Tag Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutTagAnnotationsApiResponse"/>&gt;</returns>
        Task<IPutTagAnnotationsApiResponse> PutTagAnnotationsAsync(string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 设定指定 tag 的元数据
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="putTagAnnotationsForm">Put Tag Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutTagAnnotationsApiResponse"/>?&gt;</returns>
        Task<IPutTagAnnotationsApiResponse?> PutTagAnnotationsOrDefaultAsync(string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateBlobApiResponse"/>
    /// </summary>
    public interface ICreateBlobApiResponse : CNBOpenApi.Client.IApiResponse, ICreated<CNBOpenApi.Model.ApiBlob?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ICreateBranchApiResponse"/>
    /// </summary>
    public interface ICreateBranchApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ICreateTagApiResponse"/>
    /// </summary>
    public interface ICreateTagApiResponse : CNBOpenApi.Client.IApiResponse, ICreated<CNBOpenApi.Model.ApiTag?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteBranchApiResponse"/>
    /// </summary>
    public interface IDeleteBranchApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteCommitAnnotationApiResponse"/>
    /// </summary>
    public interface IDeleteCommitAnnotationApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteCommitAssetApiResponse"/>
    /// </summary>
    public interface IDeleteCommitAssetApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteTagApiResponse"/>
    /// </summary>
    public interface IDeleteTagApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteTagAnnotationApiResponse"/>
    /// </summary>
    public interface IDeleteTagAnnotationApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetArchiveCommitChangedFilesApiResponse"/>
    /// </summary>
    public interface IGetArchiveCommitChangedFilesApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetArchiveCompareChangedFilesApiResponse"/>
    /// </summary>
    public interface IGetArchiveCompareChangedFilesApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetBranchApiResponse"/>
    /// </summary>
    public interface IGetBranchApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.ApiBranchDetail?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommitApiResponse"/>
    /// </summary>
    public interface IGetCommitApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.ApiCommit?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommitAnnotationsApiResponse"/>
    /// </summary>
    public interface IGetCommitAnnotationsApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<WebCommitAnnotation>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommitAnnotationsInBatchApiResponse"/>
    /// </summary>
    public interface IGetCommitAnnotationsInBatchApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<WebCommitAnnotationInBatch>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommitAssetsByShaApiResponse"/>
    /// </summary>
    public interface IGetCommitAssetsByShaApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<ApiCommitAsset>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommitStatusesApiResponse"/>
    /// </summary>
    public interface IGetCommitStatusesApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<ApiCommitStatus>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCompareCommitsApiResponse"/>
    /// </summary>
    public interface IGetCompareCommitsApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.ApiCompareResponse?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetContentApiResponse"/>
    /// </summary>
    public interface IGetContentApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.ApiContent?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetHeadApiResponse"/>
    /// </summary>
    public interface IGetHeadApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.OpenapiHeadRef?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetTagApiResponse"/>
    /// </summary>
    public interface IGetTagApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.ApiTag?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetTagAnnotationsApiResponse"/>
    /// </summary>
    public interface IGetTagAnnotationsApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<WebTagAnnotation>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListBranchesApiResponse"/>
    /// </summary>
    public interface IListBranchesApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<ApiBranch>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListCommitsApiResponse"/>
    /// </summary>
    public interface IListCommitsApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<ApiCommit>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListTagsApiResponse"/>
    /// </summary>
    public interface IListTagsApiResponse : CNBOpenApi.Client.IApiResponse, IOk<List<ApiTag>?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPostCommitAssetUploadConfirmationApiResponse"/>
    /// </summary>
    public interface IPostCommitAssetUploadConfirmationApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPostCommitAssetUploadURLApiResponse"/>
    /// </summary>
    public interface IPostCommitAssetUploadURLApiResponse : CNBOpenApi.Client.IApiResponse, ICreated<CNBOpenApi.Model.OpenapiCommitAssetUploadURL?>, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPutCommitAnnotationsApiResponse"/>
    /// </summary>
    public interface IPutCommitAnnotationsApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPutTagAnnotationsApiResponse"/>
    /// </summary>
    public interface IPutTagAnnotationsApiResponse : CNBOpenApi.Client.IApiResponse, INotFound<CNBOpenApi.Model.DieWebError?>, IInternalServerError<CNBOpenApi.Model.DieWebError?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class GitApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateBlob;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateBlob;

        internal void ExecuteOnCreateBlob(GitApi.CreateBlobApiResponse apiResponse)
        {
            OnCreateBlob?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateBlob(Exception exception)
        {
            OnErrorCreateBlob?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateBranch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateBranch;

        internal void ExecuteOnCreateBranch(GitApi.CreateBranchApiResponse apiResponse)
        {
            OnCreateBranch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateBranch(Exception exception)
        {
            OnErrorCreateBranch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateTag;

        internal void ExecuteOnCreateTag(GitApi.CreateTagApiResponse apiResponse)
        {
            OnCreateTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateTag(Exception exception)
        {
            OnErrorCreateTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteBranch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteBranch;

        internal void ExecuteOnDeleteBranch(GitApi.DeleteBranchApiResponse apiResponse)
        {
            OnDeleteBranch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteBranch(Exception exception)
        {
            OnErrorDeleteBranch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteCommitAnnotation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteCommitAnnotation;

        internal void ExecuteOnDeleteCommitAnnotation(GitApi.DeleteCommitAnnotationApiResponse apiResponse)
        {
            OnDeleteCommitAnnotation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteCommitAnnotation(Exception exception)
        {
            OnErrorDeleteCommitAnnotation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteCommitAsset;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteCommitAsset;

        internal void ExecuteOnDeleteCommitAsset(GitApi.DeleteCommitAssetApiResponse apiResponse)
        {
            OnDeleteCommitAsset?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteCommitAsset(Exception exception)
        {
            OnErrorDeleteCommitAsset?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteTag;

        internal void ExecuteOnDeleteTag(GitApi.DeleteTagApiResponse apiResponse)
        {
            OnDeleteTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteTag(Exception exception)
        {
            OnErrorDeleteTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteTagAnnotation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteTagAnnotation;

        internal void ExecuteOnDeleteTagAnnotation(GitApi.DeleteTagAnnotationApiResponse apiResponse)
        {
            OnDeleteTagAnnotation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteTagAnnotation(Exception exception)
        {
            OnErrorDeleteTagAnnotation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetArchiveCommitChangedFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetArchiveCommitChangedFiles;

        internal void ExecuteOnGetArchiveCommitChangedFiles(GitApi.GetArchiveCommitChangedFilesApiResponse apiResponse)
        {
            OnGetArchiveCommitChangedFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetArchiveCommitChangedFiles(Exception exception)
        {
            OnErrorGetArchiveCommitChangedFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetArchiveCompareChangedFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetArchiveCompareChangedFiles;

        internal void ExecuteOnGetArchiveCompareChangedFiles(GitApi.GetArchiveCompareChangedFilesApiResponse apiResponse)
        {
            OnGetArchiveCompareChangedFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetArchiveCompareChangedFiles(Exception exception)
        {
            OnErrorGetArchiveCompareChangedFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBranch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBranch;

        internal void ExecuteOnGetBranch(GitApi.GetBranchApiResponse apiResponse)
        {
            OnGetBranch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBranch(Exception exception)
        {
            OnErrorGetBranch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommit;

        internal void ExecuteOnGetCommit(GitApi.GetCommitApiResponse apiResponse)
        {
            OnGetCommit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommit(Exception exception)
        {
            OnErrorGetCommit?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommitAnnotations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommitAnnotations;

        internal void ExecuteOnGetCommitAnnotations(GitApi.GetCommitAnnotationsApiResponse apiResponse)
        {
            OnGetCommitAnnotations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommitAnnotations(Exception exception)
        {
            OnErrorGetCommitAnnotations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommitAnnotationsInBatch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommitAnnotationsInBatch;

        internal void ExecuteOnGetCommitAnnotationsInBatch(GitApi.GetCommitAnnotationsInBatchApiResponse apiResponse)
        {
            OnGetCommitAnnotationsInBatch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommitAnnotationsInBatch(Exception exception)
        {
            OnErrorGetCommitAnnotationsInBatch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommitAssetsBySha;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommitAssetsBySha;

        internal void ExecuteOnGetCommitAssetsBySha(GitApi.GetCommitAssetsByShaApiResponse apiResponse)
        {
            OnGetCommitAssetsBySha?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommitAssetsBySha(Exception exception)
        {
            OnErrorGetCommitAssetsBySha?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommitStatuses;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommitStatuses;

        internal void ExecuteOnGetCommitStatuses(GitApi.GetCommitStatusesApiResponse apiResponse)
        {
            OnGetCommitStatuses?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommitStatuses(Exception exception)
        {
            OnErrorGetCommitStatuses?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCompareCommits;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCompareCommits;

        internal void ExecuteOnGetCompareCommits(GitApi.GetCompareCommitsApiResponse apiResponse)
        {
            OnGetCompareCommits?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCompareCommits(Exception exception)
        {
            OnErrorGetCompareCommits?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetContent;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetContent;

        internal void ExecuteOnGetContent(GitApi.GetContentApiResponse apiResponse)
        {
            OnGetContent?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetContent(Exception exception)
        {
            OnErrorGetContent?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetHead;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetHead;

        internal void ExecuteOnGetHead(GitApi.GetHeadApiResponse apiResponse)
        {
            OnGetHead?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetHead(Exception exception)
        {
            OnErrorGetHead?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTag;

        internal void ExecuteOnGetTag(GitApi.GetTagApiResponse apiResponse)
        {
            OnGetTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTag(Exception exception)
        {
            OnErrorGetTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTagAnnotations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTagAnnotations;

        internal void ExecuteOnGetTagAnnotations(GitApi.GetTagAnnotationsApiResponse apiResponse)
        {
            OnGetTagAnnotations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTagAnnotations(Exception exception)
        {
            OnErrorGetTagAnnotations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListBranches;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListBranches;

        internal void ExecuteOnListBranches(GitApi.ListBranchesApiResponse apiResponse)
        {
            OnListBranches?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListBranches(Exception exception)
        {
            OnErrorListBranches?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListCommits;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListCommits;

        internal void ExecuteOnListCommits(GitApi.ListCommitsApiResponse apiResponse)
        {
            OnListCommits?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListCommits(Exception exception)
        {
            OnErrorListCommits?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListTags;

        internal void ExecuteOnListTags(GitApi.ListTagsApiResponse apiResponse)
        {
            OnListTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListTags(Exception exception)
        {
            OnErrorListTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostCommitAssetUploadConfirmation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostCommitAssetUploadConfirmation;

        internal void ExecuteOnPostCommitAssetUploadConfirmation(GitApi.PostCommitAssetUploadConfirmationApiResponse apiResponse)
        {
            OnPostCommitAssetUploadConfirmation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostCommitAssetUploadConfirmation(Exception exception)
        {
            OnErrorPostCommitAssetUploadConfirmation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostCommitAssetUploadURL;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostCommitAssetUploadURL;

        internal void ExecuteOnPostCommitAssetUploadURL(GitApi.PostCommitAssetUploadURLApiResponse apiResponse)
        {
            OnPostCommitAssetUploadURL?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostCommitAssetUploadURL(Exception exception)
        {
            OnErrorPostCommitAssetUploadURL?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutCommitAnnotations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutCommitAnnotations;

        internal void ExecuteOnPutCommitAnnotations(GitApi.PutCommitAnnotationsApiResponse apiResponse)
        {
            OnPutCommitAnnotations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutCommitAnnotations(Exception exception)
        {
            OnErrorPutCommitAnnotations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutTagAnnotations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutTagAnnotations;

        internal void ExecuteOnPutTagAnnotations(GitApi.PutTagAnnotationsApiResponse apiResponse)
        {
            OnPutTagAnnotations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutTagAnnotations(Exception exception)
        {
            OnErrorPutTagAnnotations?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class GitApi : IGitApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<GitApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public GitApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="GitApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GitApi(ILogger<GitApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, GitApiEvents gitApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<GitApi>();
            HttpClient = httpClient;
            Events = gitApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateBlob(ref string repo, ApiPostBlobForm postBlobForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="postBlobForm"></param>
        /// <returns></returns>
        private void ValidateCreateBlob(string repo, ApiPostBlobForm postBlobForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (postBlobForm == null)
                throw new ArgumentNullException(nameof(postBlobForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postBlobForm"></param>
        private void AfterCreateBlobDefaultImplementation(ICreateBlobApiResponse apiResponseLocalVar, string repo, ApiPostBlobForm postBlobForm)
        {
            bool suppressDefaultLog = false;
            AfterCreateBlob(ref suppressDefaultLog, apiResponseLocalVar, repo, postBlobForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postBlobForm"></param>
        partial void AfterCreateBlob(ref bool suppressDefaultLog, ICreateBlobApiResponse apiResponseLocalVar, string repo, ApiPostBlobForm postBlobForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postBlobForm"></param>
        private void OnErrorCreateBlobDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, ApiPostBlobForm postBlobForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateBlob(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, postBlobForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postBlobForm"></param>
        partial void OnErrorCreateBlob(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, ApiPostBlobForm postBlobForm);

        /// <summary>
        /// 创建一个 blob 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="postBlobForm">PostBlobForm</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBlobApiResponse"/>&gt;</returns>
        public async Task<ICreateBlobApiResponse?> CreateBlobOrDefaultAsync(string repo, ApiPostBlobForm postBlobForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateBlobAsync(repo, postBlobForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 创建一个 blob 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="postBlobForm">PostBlobForm</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBlobApiResponse"/>&gt;</returns>
        public async Task<ICreateBlobApiResponse> CreateBlobAsync(string repo, ApiPostBlobForm postBlobForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateBlob(repo, postBlobForm);

                FormatCreateBlob(ref repo, postBlobForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/blobs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/blobs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (postBlobForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postBlobForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateBlobApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateBlobApiResponse>();

                        CreateBlobApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/blobs", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateBlobDefaultImplementation(apiResponseLocalVar, repo, postBlobForm);

                        Events.ExecuteOnCreateBlob(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateBlobDefaultImplementation(e, "/{repo}/-/git/blobs", uriBuilderLocalVar.Path, repo, postBlobForm);
                Events.ExecuteOnErrorCreateBlob(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateBlobApiResponse"/>
        /// </summary>
        public partial class CreateBlobApiResponse : CNBOpenApi.Client.ApiResponse, ICreateBlobApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateBlobApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateBlobApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateBlobApiResponse(ILogger<CreateBlobApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiBlob? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiBlob>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out CNBOpenApi.Model.ApiBlob? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateBranch(ref string repo, OpenapiCreateBranchForm createBranchForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="createBranchForm"></param>
        /// <returns></returns>
        private void ValidateCreateBranch(string repo, OpenapiCreateBranchForm createBranchForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (createBranchForm == null)
                throw new ArgumentNullException(nameof(createBranchForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="createBranchForm"></param>
        private void AfterCreateBranchDefaultImplementation(ICreateBranchApiResponse apiResponseLocalVar, string repo, OpenapiCreateBranchForm createBranchForm)
        {
            bool suppressDefaultLog = false;
            AfterCreateBranch(ref suppressDefaultLog, apiResponseLocalVar, repo, createBranchForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="createBranchForm"></param>
        partial void AfterCreateBranch(ref bool suppressDefaultLog, ICreateBranchApiResponse apiResponseLocalVar, string repo, OpenapiCreateBranchForm createBranchForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="createBranchForm"></param>
        private void OnErrorCreateBranchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, OpenapiCreateBranchForm createBranchForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateBranch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, createBranchForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="createBranchForm"></param>
        partial void OnErrorCreateBranch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, OpenapiCreateBranchForm createBranchForm);

        /// <summary>
        /// 创建新分支 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="createBranchForm">Create BranchDetail Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBranchApiResponse"/>&gt;</returns>
        public async Task<ICreateBranchApiResponse?> CreateBranchOrDefaultAsync(string repo, OpenapiCreateBranchForm createBranchForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateBranchAsync(repo, createBranchForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 创建新分支 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="createBranchForm">Create BranchDetail Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateBranchApiResponse"/>&gt;</returns>
        public async Task<ICreateBranchApiResponse> CreateBranchAsync(string repo, OpenapiCreateBranchForm createBranchForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateBranch(repo, createBranchForm);

                FormatCreateBranch(ref repo, createBranchForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/branches"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/branches");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (createBranchForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createBranchForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateBranchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateBranchApiResponse>();

                        CreateBranchApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/branches", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateBranchDefaultImplementation(apiResponseLocalVar, repo, createBranchForm);

                        Events.ExecuteOnCreateBranch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateBranchDefaultImplementation(e, "/{repo}/-/git/branches", uriBuilderLocalVar.Path, repo, createBranchForm);
                Events.ExecuteOnErrorCreateBranch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateBranchApiResponse"/>
        /// </summary>
        public partial class CreateBranchApiResponse : CNBOpenApi.Client.ApiResponse, ICreateBranchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateBranchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateBranchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateBranchApiResponse(ILogger<CreateBranchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateTag(ref string repo, ApiPostTagFrom postTagForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="postTagForm"></param>
        /// <returns></returns>
        private void ValidateCreateTag(string repo, ApiPostTagFrom postTagForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (postTagForm == null)
                throw new ArgumentNullException(nameof(postTagForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postTagForm"></param>
        private void AfterCreateTagDefaultImplementation(ICreateTagApiResponse apiResponseLocalVar, string repo, ApiPostTagFrom postTagForm)
        {
            bool suppressDefaultLog = false;
            AfterCreateTag(ref suppressDefaultLog, apiResponseLocalVar, repo, postTagForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postTagForm"></param>
        partial void AfterCreateTag(ref bool suppressDefaultLog, ICreateTagApiResponse apiResponseLocalVar, string repo, ApiPostTagFrom postTagForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postTagForm"></param>
        private void OnErrorCreateTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, ApiPostTagFrom postTagForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, postTagForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="postTagForm"></param>
        partial void OnErrorCreateTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, ApiPostTagFrom postTagForm);

        /// <summary>
        /// 创建一个 tag 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="postTagForm">PostTagFrom</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTagApiResponse"/>&gt;</returns>
        public async Task<ICreateTagApiResponse?> CreateTagOrDefaultAsync(string repo, ApiPostTagFrom postTagForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateTagAsync(repo, postTagForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 创建一个 tag 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="postTagForm">PostTagFrom</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTagApiResponse"/>&gt;</returns>
        public async Task<ICreateTagApiResponse> CreateTagAsync(string repo, ApiPostTagFrom postTagForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateTag(repo, postTagForm);

                FormatCreateTag(ref repo, postTagForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tags");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (postTagForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postTagForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateTagApiResponse>();

                        CreateTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateTagDefaultImplementation(apiResponseLocalVar, repo, postTagForm);

                        Events.ExecuteOnCreateTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateTagDefaultImplementation(e, "/{repo}/-/git/tags", uriBuilderLocalVar.Path, repo, postTagForm);
                Events.ExecuteOnErrorCreateTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateTagApiResponse"/>
        /// </summary>
        public partial class CreateTagApiResponse : CNBOpenApi.Client.ApiResponse, ICreateTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTagApiResponse(ILogger<CreateTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiTag? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiTag>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out CNBOpenApi.Model.ApiTag? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteBranch(ref string repo, ref string branch);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        /// <returns></returns>
        private void ValidateDeleteBranch(string repo, string branch)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (branch == null)
                throw new ArgumentNullException(nameof(branch));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        private void AfterDeleteBranchDefaultImplementation(IDeleteBranchApiResponse apiResponseLocalVar, string repo, string branch)
        {
            bool suppressDefaultLog = false;
            AfterDeleteBranch(ref suppressDefaultLog, apiResponseLocalVar, repo, branch);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        partial void AfterDeleteBranch(ref bool suppressDefaultLog, IDeleteBranchApiResponse apiResponseLocalVar, string repo, string branch);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        private void OnErrorDeleteBranchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string branch)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteBranch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, branch);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        partial void OnErrorDeleteBranch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string branch);

        /// <summary>
        /// 删除指定分支 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBranchApiResponse"/>&gt;</returns>
        public async Task<IDeleteBranchApiResponse?> DeleteBranchOrDefaultAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteBranchAsync(repo, branch, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 删除指定分支 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBranchApiResponse"/>&gt;</returns>
        public async Task<IDeleteBranchApiResponse> DeleteBranchAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteBranch(repo, branch);

                FormatDeleteBranch(ref repo, ref branch);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/branches/{branch}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/branches/{branch}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bbranch%7D", Uri.EscapeDataString(branch.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteBranchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteBranchApiResponse>();

                        DeleteBranchApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/branches/{branch}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteBranchDefaultImplementation(apiResponseLocalVar, repo, branch);

                        Events.ExecuteOnDeleteBranch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteBranchDefaultImplementation(e, "/{repo}/-/git/branches/{branch}", uriBuilderLocalVar.Path, repo, branch);
                Events.ExecuteOnErrorDeleteBranch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteBranchApiResponse"/>
        /// </summary>
        public partial class DeleteBranchApiResponse : CNBOpenApi.Client.ApiResponse, IDeleteBranchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteBranchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteBranchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteBranchApiResponse(ILogger<DeleteBranchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteCommitAnnotation(ref string repo, ref string sha, ref string key);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        private void ValidateDeleteCommitAnnotation(string repo, string sha, string key)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha == null)
                throw new ArgumentNullException(nameof(sha));

            if (key == null)
                throw new ArgumentNullException(nameof(key));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="key"></param>
        private void AfterDeleteCommitAnnotationDefaultImplementation(IDeleteCommitAnnotationApiResponse apiResponseLocalVar, string repo, string sha, string key)
        {
            bool suppressDefaultLog = false;
            AfterDeleteCommitAnnotation(ref suppressDefaultLog, apiResponseLocalVar, repo, sha, key);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="key"></param>
        partial void AfterDeleteCommitAnnotation(ref bool suppressDefaultLog, IDeleteCommitAnnotationApiResponse apiResponseLocalVar, string repo, string sha, string key);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="key"></param>
        private void OnErrorDeleteCommitAnnotationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha, string key)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteCommitAnnotation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha, key);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="key"></param>
        partial void OnErrorDeleteCommitAnnotation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha, string key);

        /// <summary>
        /// 删除指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="key">commit annotation key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAnnotationApiResponse"/>&gt;</returns>
        public async Task<IDeleteCommitAnnotationApiResponse?> DeleteCommitAnnotationOrDefaultAsync(string repo, string sha, string key, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteCommitAnnotationAsync(repo, sha, key, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 删除指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="key">commit annotation key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAnnotationApiResponse"/>&gt;</returns>
        public async Task<IDeleteCommitAnnotationApiResponse> DeleteCommitAnnotationAsync(string repo, string sha, string key, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteCommitAnnotation(repo, sha, key);

                FormatDeleteCommitAnnotation(ref repo, ref sha, ref key);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-annotations/{sha}/{key}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-annotations/{sha}/{key}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha%7D", Uri.EscapeDataString(sha.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bkey%7D", Uri.EscapeDataString(key.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteCommitAnnotationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteCommitAnnotationApiResponse>();

                        DeleteCommitAnnotationApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-annotations/{sha}/{key}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteCommitAnnotationDefaultImplementation(apiResponseLocalVar, repo, sha, key);

                        Events.ExecuteOnDeleteCommitAnnotation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteCommitAnnotationDefaultImplementation(e, "/{repo}/-/git/commit-annotations/{sha}/{key}", uriBuilderLocalVar.Path, repo, sha, key);
                Events.ExecuteOnErrorDeleteCommitAnnotation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteCommitAnnotationApiResponse"/>
        /// </summary>
        public partial class DeleteCommitAnnotationApiResponse : CNBOpenApi.Client.ApiResponse, IDeleteCommitAnnotationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteCommitAnnotationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteCommitAnnotationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteCommitAnnotationApiResponse(ILogger<DeleteCommitAnnotationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteCommitAsset(ref string repo, ref string sha1, ref int assetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <returns></returns>
        private void ValidateDeleteCommitAsset(string repo, string sha1)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha1 == null)
                throw new ArgumentNullException(nameof(sha1));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="assetId"></param>
        private void AfterDeleteCommitAssetDefaultImplementation(IDeleteCommitAssetApiResponse apiResponseLocalVar, string repo, string sha1, int assetId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteCommitAsset(ref suppressDefaultLog, apiResponseLocalVar, repo, sha1, assetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="assetId"></param>
        partial void AfterDeleteCommitAsset(ref bool suppressDefaultLog, IDeleteCommitAssetApiResponse apiResponseLocalVar, string repo, string sha1, int assetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="assetId"></param>
        private void OnErrorDeleteCommitAssetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha1, int assetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteCommitAsset(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha1, assetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="assetId"></param>
        partial void OnErrorDeleteCommitAsset(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha1, int assetId);

        /// <summary>
        /// 删除指定 commit 的附件 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="assetId">asset id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAssetApiResponse"/>&gt;</returns>
        public async Task<IDeleteCommitAssetApiResponse?> DeleteCommitAssetOrDefaultAsync(string repo, string sha1, int assetId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteCommitAssetAsync(repo, sha1, assetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 删除指定 commit 的附件 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="assetId">asset id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommitAssetApiResponse"/>&gt;</returns>
        public async Task<IDeleteCommitAssetApiResponse> DeleteCommitAssetAsync(string repo, string sha1, int assetId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteCommitAsset(repo, sha1);

                FormatDeleteCommitAsset(ref repo, ref sha1, ref assetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-assets/{sha1}/{asset_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-assets/{sha1}/{asset_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha1%7D", Uri.EscapeDataString(sha1.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id%7D", Uri.EscapeDataString(assetId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteCommitAssetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteCommitAssetApiResponse>();

                        DeleteCommitAssetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-assets/{sha1}/{asset_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteCommitAssetDefaultImplementation(apiResponseLocalVar, repo, sha1, assetId);

                        Events.ExecuteOnDeleteCommitAsset(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteCommitAssetDefaultImplementation(e, "/{repo}/-/git/commit-assets/{sha1}/{asset_id}", uriBuilderLocalVar.Path, repo, sha1, assetId);
                Events.ExecuteOnErrorDeleteCommitAsset(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteCommitAssetApiResponse"/>
        /// </summary>
        public partial class DeleteCommitAssetApiResponse : CNBOpenApi.Client.ApiResponse, IDeleteCommitAssetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteCommitAssetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteCommitAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteCommitAssetApiResponse(ILogger<DeleteCommitAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteTag(ref string repo, ref string tag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <returns></returns>
        private void ValidateDeleteTag(string repo, string tag)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (tag == null)
                throw new ArgumentNullException(nameof(tag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        private void AfterDeleteTagDefaultImplementation(IDeleteTagApiResponse apiResponseLocalVar, string repo, string tag)
        {
            bool suppressDefaultLog = false;
            AfterDeleteTag(ref suppressDefaultLog, apiResponseLocalVar, repo, tag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        partial void AfterDeleteTag(ref bool suppressDefaultLog, IDeleteTagApiResponse apiResponseLocalVar, string repo, string tag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        private void OnErrorDeleteTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, tag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        partial void OnErrorDeleteTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag);

        /// <summary>
        /// 删除指定标签 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagApiResponse"/>&gt;</returns>
        public async Task<IDeleteTagApiResponse?> DeleteTagOrDefaultAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteTagAsync(repo, tag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 删除指定标签 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagApiResponse"/>&gt;</returns>
        public async Task<IDeleteTagApiResponse> DeleteTagAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteTag(repo, tag);

                FormatDeleteTag(ref repo, ref tag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tags/{tag}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tags/{tag}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btag%7D", Uri.EscapeDataString(tag.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteTagApiResponse>();

                        DeleteTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tags/{tag}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteTagDefaultImplementation(apiResponseLocalVar, repo, tag);

                        Events.ExecuteOnDeleteTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteTagDefaultImplementation(e, "/{repo}/-/git/tags/{tag}", uriBuilderLocalVar.Path, repo, tag);
                Events.ExecuteOnErrorDeleteTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteTagApiResponse"/>
        /// </summary>
        public partial class DeleteTagApiResponse : CNBOpenApi.Client.ApiResponse, IDeleteTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteTagApiResponse(ILogger<DeleteTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteTagAnnotation(ref string repo, ref string tagWithKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="tagWithKey"></param>
        /// <returns></returns>
        private void ValidateDeleteTagAnnotation(string repo, string tagWithKey)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (tagWithKey == null)
                throw new ArgumentNullException(nameof(tagWithKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tagWithKey"></param>
        private void AfterDeleteTagAnnotationDefaultImplementation(IDeleteTagAnnotationApiResponse apiResponseLocalVar, string repo, string tagWithKey)
        {
            bool suppressDefaultLog = false;
            AfterDeleteTagAnnotation(ref suppressDefaultLog, apiResponseLocalVar, repo, tagWithKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tagWithKey"></param>
        partial void AfterDeleteTagAnnotation(ref bool suppressDefaultLog, IDeleteTagAnnotationApiResponse apiResponseLocalVar, string repo, string tagWithKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tagWithKey"></param>
        private void OnErrorDeleteTagAnnotationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tagWithKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteTagAnnotation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, tagWithKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tagWithKey"></param>
        partial void OnErrorDeleteTagAnnotation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tagWithKey);

        /// <summary>
        /// 删除指定 tag 的元数据 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="tagWithKey">tag with key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagAnnotationApiResponse"/>&gt;</returns>
        public async Task<IDeleteTagAnnotationApiResponse?> DeleteTagAnnotationOrDefaultAsync(string repo, string tagWithKey, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteTagAnnotationAsync(repo, tagWithKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 删除指定 tag 的元数据 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tagWithKey">tag with key</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTagAnnotationApiResponse"/>&gt;</returns>
        public async Task<IDeleteTagAnnotationApiResponse> DeleteTagAnnotationAsync(string repo, string tagWithKey, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteTagAnnotation(repo, tagWithKey);

                FormatDeleteTagAnnotation(ref repo, ref tagWithKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tag-annotations/{tag_with_key}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tag-annotations/{tag_with_key}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btag_with_key%7D", Uri.EscapeDataString(tagWithKey.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteTagAnnotationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteTagAnnotationApiResponse>();

                        DeleteTagAnnotationApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tag-annotations/{tag_with_key}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteTagAnnotationDefaultImplementation(apiResponseLocalVar, repo, tagWithKey);

                        Events.ExecuteOnDeleteTagAnnotation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteTagAnnotationDefaultImplementation(e, "/{repo}/-/git/tag-annotations/{tag_with_key}", uriBuilderLocalVar.Path, repo, tagWithKey);
                Events.ExecuteOnErrorDeleteTagAnnotation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteTagAnnotationApiResponse"/>
        /// </summary>
        public partial class DeleteTagAnnotationApiResponse : CNBOpenApi.Client.ApiResponse, IDeleteTagAnnotationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteTagAnnotationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteTagAnnotationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteTagAnnotationApiResponse(ILogger<DeleteTagAnnotationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetArchiveCommitChangedFiles(ref string repo, ref string sha1);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <returns></returns>
        private void ValidateGetArchiveCommitChangedFiles(string repo, string sha1)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha1 == null)
                throw new ArgumentNullException(nameof(sha1));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        private void AfterGetArchiveCommitChangedFilesDefaultImplementation(IGetArchiveCommitChangedFilesApiResponse apiResponseLocalVar, string repo, string sha1)
        {
            bool suppressDefaultLog = false;
            AfterGetArchiveCommitChangedFiles(ref suppressDefaultLog, apiResponseLocalVar, repo, sha1);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        partial void AfterGetArchiveCommitChangedFiles(ref bool suppressDefaultLog, IGetArchiveCommitChangedFilesApiResponse apiResponseLocalVar, string repo, string sha1);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        private void OnErrorGetArchiveCommitChangedFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha1)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetArchiveCommitChangedFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha1);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        partial void OnErrorGetArchiveCommitChangedFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha1);

        /// <summary>
        /// 打包下载 commit 变更文件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha1">commit sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCommitChangedFilesApiResponse"/>&gt;</returns>
        public async Task<IGetArchiveCommitChangedFilesApiResponse?> GetArchiveCommitChangedFilesOrDefaultAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetArchiveCommitChangedFilesAsync(repo, sha1, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 打包下载 commit 变更文件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">commit sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCommitChangedFilesApiResponse"/>&gt;</returns>
        public async Task<IGetArchiveCommitChangedFilesApiResponse> GetArchiveCommitChangedFilesAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetArchiveCommitChangedFiles(repo, sha1);

                FormatGetArchiveCommitChangedFiles(ref repo, ref sha1);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/archive-commit-changed-files/{sha1}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/archive-commit-changed-files/{sha1}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha1%7D", Uri.EscapeDataString(sha1.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetArchiveCommitChangedFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetArchiveCommitChangedFilesApiResponse>();

                        GetArchiveCommitChangedFilesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/archive-commit-changed-files/{sha1}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetArchiveCommitChangedFilesDefaultImplementation(apiResponseLocalVar, repo, sha1);

                        Events.ExecuteOnGetArchiveCommitChangedFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetArchiveCommitChangedFilesDefaultImplementation(e, "/{repo}/-/git/archive-commit-changed-files/{sha1}", uriBuilderLocalVar.Path, repo, sha1);
                Events.ExecuteOnErrorGetArchiveCommitChangedFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetArchiveCommitChangedFilesApiResponse"/>
        /// </summary>
        public partial class GetArchiveCommitChangedFilesApiResponse : CNBOpenApi.Client.ApiResponse, IGetArchiveCommitChangedFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetArchiveCommitChangedFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetArchiveCommitChangedFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetArchiveCommitChangedFilesApiResponse(ILogger<GetArchiveCommitChangedFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetArchiveCompareChangedFiles(ref string repo, ref string baseHead);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        /// <returns></returns>
        private void ValidateGetArchiveCompareChangedFiles(string repo, string baseHead)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (baseHead == null)
                throw new ArgumentNullException(nameof(baseHead));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        private void AfterGetArchiveCompareChangedFilesDefaultImplementation(IGetArchiveCompareChangedFilesApiResponse apiResponseLocalVar, string repo, string baseHead)
        {
            bool suppressDefaultLog = false;
            AfterGetArchiveCompareChangedFiles(ref suppressDefaultLog, apiResponseLocalVar, repo, baseHead);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        partial void AfterGetArchiveCompareChangedFiles(ref bool suppressDefaultLog, IGetArchiveCompareChangedFilesApiResponse apiResponseLocalVar, string repo, string baseHead);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        private void OnErrorGetArchiveCompareChangedFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string baseHead)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetArchiveCompareChangedFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, baseHead);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        partial void OnErrorGetArchiveCompareChangedFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string baseHead);

        /// <summary>
        /// 打包下载两次 ref 之间的变更文件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCompareChangedFilesApiResponse"/>&gt;</returns>
        public async Task<IGetArchiveCompareChangedFilesApiResponse?> GetArchiveCompareChangedFilesOrDefaultAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetArchiveCompareChangedFilesAsync(repo, baseHead, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 打包下载两次 ref 之间的变更文件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetArchiveCompareChangedFilesApiResponse"/>&gt;</returns>
        public async Task<IGetArchiveCompareChangedFilesApiResponse> GetArchiveCompareChangedFilesAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetArchiveCompareChangedFiles(repo, baseHead);

                FormatGetArchiveCompareChangedFiles(ref repo, ref baseHead);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/archive-compare-changed-files/{base_head}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/archive-compare-changed-files/{base_head}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bbase_head%7D", Uri.EscapeDataString(baseHead.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetArchiveCompareChangedFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetArchiveCompareChangedFilesApiResponse>();

                        GetArchiveCompareChangedFilesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/archive-compare-changed-files/{base_head}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetArchiveCompareChangedFilesDefaultImplementation(apiResponseLocalVar, repo, baseHead);

                        Events.ExecuteOnGetArchiveCompareChangedFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetArchiveCompareChangedFilesDefaultImplementation(e, "/{repo}/-/git/archive-compare-changed-files/{base_head}", uriBuilderLocalVar.Path, repo, baseHead);
                Events.ExecuteOnErrorGetArchiveCompareChangedFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetArchiveCompareChangedFilesApiResponse"/>
        /// </summary>
        public partial class GetArchiveCompareChangedFilesApiResponse : CNBOpenApi.Client.ApiResponse, IGetArchiveCompareChangedFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetArchiveCompareChangedFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetArchiveCompareChangedFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetArchiveCompareChangedFilesApiResponse(ILogger<GetArchiveCompareChangedFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetBranch(ref string repo, ref string branch);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        /// <returns></returns>
        private void ValidateGetBranch(string repo, string branch)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (branch == null)
                throw new ArgumentNullException(nameof(branch));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        private void AfterGetBranchDefaultImplementation(IGetBranchApiResponse apiResponseLocalVar, string repo, string branch)
        {
            bool suppressDefaultLog = false;
            AfterGetBranch(ref suppressDefaultLog, apiResponseLocalVar, repo, branch);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        partial void AfterGetBranch(ref bool suppressDefaultLog, IGetBranchApiResponse apiResponseLocalVar, string repo, string branch);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        private void OnErrorGetBranchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string branch)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBranch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, branch);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="branch"></param>
        partial void OnErrorGetBranch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string branch);

        /// <summary>
        /// 查询指定分支 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBranchApiResponse"/>&gt;</returns>
        public async Task<IGetBranchApiResponse?> GetBranchOrDefaultAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBranchAsync(repo, branch, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定分支 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="branch">branch name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBranchApiResponse"/>&gt;</returns>
        public async Task<IGetBranchApiResponse> GetBranchAsync(string repo, string branch, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBranch(repo, branch);

                FormatGetBranch(ref repo, ref branch);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/branches/{branch}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/branches/{branch}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bbranch%7D", Uri.EscapeDataString(branch.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetBranchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBranchApiResponse>();

                        GetBranchApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/branches/{branch}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetBranchDefaultImplementation(apiResponseLocalVar, repo, branch);

                        Events.ExecuteOnGetBranch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBranchDefaultImplementation(e, "/{repo}/-/git/branches/{branch}", uriBuilderLocalVar.Path, repo, branch);
                Events.ExecuteOnErrorGetBranch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBranchApiResponse"/>
        /// </summary>
        public partial class GetBranchApiResponse : CNBOpenApi.Client.ApiResponse, IGetBranchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBranchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBranchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBranchApiResponse(ILogger<GetBranchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiBranchDetail? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiBranchDetail>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.ApiBranchDetail? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommit(ref string repo, ref string varRef);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="varRef"></param>
        /// <returns></returns>
        private void ValidateGetCommit(string repo, string varRef)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (varRef == null)
                throw new ArgumentNullException(nameof(varRef));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="varRef"></param>
        private void AfterGetCommitDefaultImplementation(IGetCommitApiResponse apiResponseLocalVar, string repo, string varRef)
        {
            bool suppressDefaultLog = false;
            AfterGetCommit(ref suppressDefaultLog, apiResponseLocalVar, repo, varRef);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="varRef"></param>
        partial void AfterGetCommit(ref bool suppressDefaultLog, IGetCommitApiResponse apiResponseLocalVar, string repo, string varRef);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="varRef"></param>
        private void OnErrorGetCommitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string varRef)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, varRef);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="varRef"></param>
        partial void OnErrorGetCommit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string varRef);

        /// <summary>
        /// 查询指定 commit 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="varRef">ref</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitApiResponse"/>&gt;</returns>
        public async Task<IGetCommitApiResponse?> GetCommitOrDefaultAsync(string repo, string varRef, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommitAsync(repo, varRef, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 commit 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="varRef">ref</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitApiResponse"/>&gt;</returns>
        public async Task<IGetCommitApiResponse> GetCommitAsync(string repo, string varRef, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCommit(repo, varRef);

                FormatGetCommit(ref repo, ref varRef);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commits/{ref}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commits/{ref}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bref%7D", Uri.EscapeDataString(varRef.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommitApiResponse>();

                        GetCommitApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commits/{ref}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommitDefaultImplementation(apiResponseLocalVar, repo, varRef);

                        Events.ExecuteOnGetCommit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommitDefaultImplementation(e, "/{repo}/-/git/commits/{ref}", uriBuilderLocalVar.Path, repo, varRef);
                Events.ExecuteOnErrorGetCommit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommitApiResponse"/>
        /// </summary>
        public partial class GetCommitApiResponse : CNBOpenApi.Client.ApiResponse, IGetCommitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommitApiResponse(ILogger<GetCommitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiCommit? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiCommit>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.ApiCommit? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommitAnnotations(ref string repo, ref string sha);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <returns></returns>
        private void ValidateGetCommitAnnotations(string repo, string sha)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha == null)
                throw new ArgumentNullException(nameof(sha));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        private void AfterGetCommitAnnotationsDefaultImplementation(IGetCommitAnnotationsApiResponse apiResponseLocalVar, string repo, string sha)
        {
            bool suppressDefaultLog = false;
            AfterGetCommitAnnotations(ref suppressDefaultLog, apiResponseLocalVar, repo, sha);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        partial void AfterGetCommitAnnotations(ref bool suppressDefaultLog, IGetCommitAnnotationsApiResponse apiResponseLocalVar, string repo, string sha);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        private void OnErrorGetCommitAnnotationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommitAnnotations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        partial void OnErrorGetCommitAnnotations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha);

        /// <summary>
        /// 查询指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAnnotationsApiResponse?> GetCommitAnnotationsOrDefaultAsync(string repo, string sha, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommitAnnotationsAsync(repo, sha, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAnnotationsApiResponse> GetCommitAnnotationsAsync(string repo, string sha, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCommitAnnotations(repo, sha);

                FormatGetCommitAnnotations(ref repo, ref sha);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-annotations/{sha}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-annotations/{sha}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha%7D", Uri.EscapeDataString(sha.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommitAnnotationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommitAnnotationsApiResponse>();

                        GetCommitAnnotationsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-annotations/{sha}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommitAnnotationsDefaultImplementation(apiResponseLocalVar, repo, sha);

                        Events.ExecuteOnGetCommitAnnotations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommitAnnotationsDefaultImplementation(e, "/{repo}/-/git/commit-annotations/{sha}", uriBuilderLocalVar.Path, repo, sha);
                Events.ExecuteOnErrorGetCommitAnnotations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommitAnnotationsApiResponse"/>
        /// </summary>
        public partial class GetCommitAnnotationsApiResponse : CNBOpenApi.Client.ApiResponse, IGetCommitAnnotationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommitAnnotationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommitAnnotationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommitAnnotationsApiResponse(ILogger<GetCommitAnnotationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<WebCommitAnnotation>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<WebCommitAnnotation>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<WebCommitAnnotation>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommitAnnotationsInBatch(ref string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="getCommitAnnotationsForm"></param>
        /// <returns></returns>
        private void ValidateGetCommitAnnotationsInBatch(string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (getCommitAnnotationsForm == null)
                throw new ArgumentNullException(nameof(getCommitAnnotationsForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="getCommitAnnotationsForm"></param>
        private void AfterGetCommitAnnotationsInBatchDefaultImplementation(IGetCommitAnnotationsInBatchApiResponse apiResponseLocalVar, string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm)
        {
            bool suppressDefaultLog = false;
            AfterGetCommitAnnotationsInBatch(ref suppressDefaultLog, apiResponseLocalVar, repo, getCommitAnnotationsForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="getCommitAnnotationsForm"></param>
        partial void AfterGetCommitAnnotationsInBatch(ref bool suppressDefaultLog, IGetCommitAnnotationsInBatchApiResponse apiResponseLocalVar, string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="getCommitAnnotationsForm"></param>
        private void OnErrorGetCommitAnnotationsInBatchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommitAnnotationsInBatch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, getCommitAnnotationsForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="getCommitAnnotationsForm"></param>
        partial void OnErrorGetCommitAnnotationsInBatch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm);

        /// <summary>
        /// 查询指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="getCommitAnnotationsForm">Get Commit Annotations In Batch Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsInBatchApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAnnotationsInBatchApiResponse?> GetCommitAnnotationsInBatchOrDefaultAsync(string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommitAnnotationsInBatchAsync(repo, getCommitAnnotationsForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="getCommitAnnotationsForm">Get Commit Annotations In Batch Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAnnotationsInBatchApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAnnotationsInBatchApiResponse> GetCommitAnnotationsInBatchAsync(string repo, WebGetCommitAnnotationsInBatchForm getCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCommitAnnotationsInBatch(repo, getCommitAnnotationsForm);

                FormatGetCommitAnnotationsInBatch(ref repo, getCommitAnnotationsForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-annotations-in-batch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-annotations-in-batch");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (getCommitAnnotationsForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(getCommitAnnotationsForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommitAnnotationsInBatchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommitAnnotationsInBatchApiResponse>();

                        GetCommitAnnotationsInBatchApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-annotations-in-batch", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommitAnnotationsInBatchDefaultImplementation(apiResponseLocalVar, repo, getCommitAnnotationsForm);

                        Events.ExecuteOnGetCommitAnnotationsInBatch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommitAnnotationsInBatchDefaultImplementation(e, "/{repo}/-/git/commit-annotations-in-batch", uriBuilderLocalVar.Path, repo, getCommitAnnotationsForm);
                Events.ExecuteOnErrorGetCommitAnnotationsInBatch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommitAnnotationsInBatchApiResponse"/>
        /// </summary>
        public partial class GetCommitAnnotationsInBatchApiResponse : CNBOpenApi.Client.ApiResponse, IGetCommitAnnotationsInBatchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommitAnnotationsInBatchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommitAnnotationsInBatchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommitAnnotationsInBatchApiResponse(ILogger<GetCommitAnnotationsInBatchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<WebCommitAnnotationInBatch>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<WebCommitAnnotationInBatch>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<WebCommitAnnotationInBatch>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommitAssetsBySha(ref string repo, ref string sha1);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <returns></returns>
        private void ValidateGetCommitAssetsBySha(string repo, string sha1)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha1 == null)
                throw new ArgumentNullException(nameof(sha1));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        private void AfterGetCommitAssetsByShaDefaultImplementation(IGetCommitAssetsByShaApiResponse apiResponseLocalVar, string repo, string sha1)
        {
            bool suppressDefaultLog = false;
            AfterGetCommitAssetsBySha(ref suppressDefaultLog, apiResponseLocalVar, repo, sha1);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        partial void AfterGetCommitAssetsBySha(ref bool suppressDefaultLog, IGetCommitAssetsByShaApiResponse apiResponseLocalVar, string repo, string sha1);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        private void OnErrorGetCommitAssetsByShaDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha1)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommitAssetsBySha(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha1);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        partial void OnErrorGetCommitAssetsBySha(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha1);

        /// <summary>
        /// 查询指定 commit 的附件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsByShaApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAssetsByShaApiResponse?> GetCommitAssetsByShaOrDefaultAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommitAssetsByShaAsync(repo, sha1, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 commit 的附件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsByShaApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAssetsByShaApiResponse> GetCommitAssetsByShaAsync(string repo, string sha1, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCommitAssetsBySha(repo, sha1);

                FormatGetCommitAssetsBySha(ref repo, ref sha1);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-assets/{sha1}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-assets/{sha1}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha1%7D", Uri.EscapeDataString(sha1.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommitAssetsByShaApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommitAssetsByShaApiResponse>();

                        GetCommitAssetsByShaApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-assets/{sha1}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommitAssetsByShaDefaultImplementation(apiResponseLocalVar, repo, sha1);

                        Events.ExecuteOnGetCommitAssetsBySha(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommitAssetsByShaDefaultImplementation(e, "/{repo}/-/git/commit-assets/{sha1}", uriBuilderLocalVar.Path, repo, sha1);
                Events.ExecuteOnErrorGetCommitAssetsBySha(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommitAssetsByShaApiResponse"/>
        /// </summary>
        public partial class GetCommitAssetsByShaApiResponse : CNBOpenApi.Client.ApiResponse, IGetCommitAssetsByShaApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommitAssetsByShaApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommitAssetsByShaApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommitAssetsByShaApiResponse(ILogger<GetCommitAssetsByShaApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ApiCommitAsset>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ApiCommitAsset>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ApiCommitAsset>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommitStatuses(ref string repo, ref string commitish);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="commitish"></param>
        /// <returns></returns>
        private void ValidateGetCommitStatuses(string repo, string commitish)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (commitish == null)
                throw new ArgumentNullException(nameof(commitish));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="commitish"></param>
        private void AfterGetCommitStatusesDefaultImplementation(IGetCommitStatusesApiResponse apiResponseLocalVar, string repo, string commitish)
        {
            bool suppressDefaultLog = false;
            AfterGetCommitStatuses(ref suppressDefaultLog, apiResponseLocalVar, repo, commitish);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="commitish"></param>
        partial void AfterGetCommitStatuses(ref bool suppressDefaultLog, IGetCommitStatusesApiResponse apiResponseLocalVar, string repo, string commitish);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="commitish"></param>
        private void OnErrorGetCommitStatusesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string commitish)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommitStatuses(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, commitish);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="commitish"></param>
        partial void OnErrorGetCommitStatuses(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string commitish);

        /// <summary>
        /// 查询指定 commit 的 check statuses 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="commitish">commitish</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitStatusesApiResponse"/>&gt;</returns>
        public async Task<IGetCommitStatusesApiResponse?> GetCommitStatusesOrDefaultAsync(string repo, string commitish, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommitStatusesAsync(repo, commitish, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 commit 的 check statuses 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="commitish">commitish</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitStatusesApiResponse"/>&gt;</returns>
        public async Task<IGetCommitStatusesApiResponse> GetCommitStatusesAsync(string repo, string commitish, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCommitStatuses(repo, commitish);

                FormatGetCommitStatuses(ref repo, ref commitish);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-statuses/{commitish}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-statuses/{commitish}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcommitish%7D", Uri.EscapeDataString(commitish.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommitStatusesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommitStatusesApiResponse>();

                        GetCommitStatusesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-statuses/{commitish}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommitStatusesDefaultImplementation(apiResponseLocalVar, repo, commitish);

                        Events.ExecuteOnGetCommitStatuses(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommitStatusesDefaultImplementation(e, "/{repo}/-/git/commit-statuses/{commitish}", uriBuilderLocalVar.Path, repo, commitish);
                Events.ExecuteOnErrorGetCommitStatuses(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommitStatusesApiResponse"/>
        /// </summary>
        public partial class GetCommitStatusesApiResponse : CNBOpenApi.Client.ApiResponse, IGetCommitStatusesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommitStatusesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommitStatusesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommitStatusesApiResponse(ILogger<GetCommitStatusesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ApiCommitStatus>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ApiCommitStatus>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ApiCommitStatus>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCompareCommits(ref string repo, ref string baseHead);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        /// <returns></returns>
        private void ValidateGetCompareCommits(string repo, string baseHead)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (baseHead == null)
                throw new ArgumentNullException(nameof(baseHead));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        private void AfterGetCompareCommitsDefaultImplementation(IGetCompareCommitsApiResponse apiResponseLocalVar, string repo, string baseHead)
        {
            bool suppressDefaultLog = false;
            AfterGetCompareCommits(ref suppressDefaultLog, apiResponseLocalVar, repo, baseHead);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        partial void AfterGetCompareCommits(ref bool suppressDefaultLog, IGetCompareCommitsApiResponse apiResponseLocalVar, string repo, string baseHead);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        private void OnErrorGetCompareCommitsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string baseHead)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCompareCommits(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, baseHead);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="baseHead"></param>
        partial void OnErrorGetCompareCommits(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string baseHead);

        /// <summary>
        /// 对比 base...head 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCompareCommitsApiResponse"/>&gt;</returns>
        public async Task<IGetCompareCommitsApiResponse?> GetCompareCommitsOrDefaultAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCompareCommitsAsync(repo, baseHead, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 对比 base...head 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="baseHead">base...head</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCompareCommitsApiResponse"/>&gt;</returns>
        public async Task<IGetCompareCommitsApiResponse> GetCompareCommitsAsync(string repo, string baseHead, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCompareCommits(repo, baseHead);

                FormatGetCompareCommits(ref repo, ref baseHead);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/compare/{base_head}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/compare/{base_head}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bbase_head%7D", Uri.EscapeDataString(baseHead.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCompareCommitsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCompareCommitsApiResponse>();

                        GetCompareCommitsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/compare/{base_head}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCompareCommitsDefaultImplementation(apiResponseLocalVar, repo, baseHead);

                        Events.ExecuteOnGetCompareCommits(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCompareCommitsDefaultImplementation(e, "/{repo}/-/git/compare/{base_head}", uriBuilderLocalVar.Path, repo, baseHead);
                Events.ExecuteOnErrorGetCompareCommits(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCompareCommitsApiResponse"/>
        /// </summary>
        public partial class GetCompareCommitsApiResponse : CNBOpenApi.Client.ApiResponse, IGetCompareCommitsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCompareCommitsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCompareCommitsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCompareCommitsApiResponse(ILogger<GetCompareCommitsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiCompareResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiCompareResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.ApiCompareResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetContent(ref string repo, ref string filePath, ref Option<string> varRef);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="filePath"></param>
        /// <param name="varRef"></param>
        /// <returns></returns>
        private void ValidateGetContent(string repo, string filePath, Option<string> varRef)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (filePath == null)
                throw new ArgumentNullException(nameof(filePath));

            if (varRef.IsSet && varRef.Value == null)
                throw new ArgumentNullException(nameof(varRef));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="filePath"></param>
        /// <param name="varRef"></param>
        private void AfterGetContentDefaultImplementation(IGetContentApiResponse apiResponseLocalVar, string repo, string filePath, Option<string> varRef)
        {
            bool suppressDefaultLog = false;
            AfterGetContent(ref suppressDefaultLog, apiResponseLocalVar, repo, filePath, varRef);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="filePath"></param>
        /// <param name="varRef"></param>
        partial void AfterGetContent(ref bool suppressDefaultLog, IGetContentApiResponse apiResponseLocalVar, string repo, string filePath, Option<string> varRef);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="filePath"></param>
        /// <param name="varRef"></param>
        private void OnErrorGetContentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string filePath, Option<string> varRef)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetContent(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, filePath, varRef);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="filePath"></param>
        /// <param name="varRef"></param>
        partial void OnErrorGetContent(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string filePath, Option<string> varRef);

        /// <summary>
        /// 查询仓库文件列表或文件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="filePath">path</param>
        /// <param name="varRef">ref (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetContentApiResponse"/>&gt;</returns>
        public async Task<IGetContentApiResponse?> GetContentOrDefaultAsync(string repo, string filePath, Option<string> varRef = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetContentAsync(repo, filePath, varRef, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询仓库文件列表或文件 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="filePath">path</param>
        /// <param name="varRef">ref (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetContentApiResponse"/>&gt;</returns>
        public async Task<IGetContentApiResponse> GetContentAsync(string repo, string filePath, Option<string> varRef = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetContent(repo, filePath, varRef);

                FormatGetContent(ref repo, ref filePath, ref varRef);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/contents/{file_path}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/contents/{file_path}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfile_path%7D", Uri.EscapeDataString(filePath.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (varRef.IsSet)
                        parseQueryStringLocalVar["ref"] = ClientUtils.ParameterToString(varRef.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetContentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetContentApiResponse>();

                        GetContentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/contents/{file_path}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetContentDefaultImplementation(apiResponseLocalVar, repo, filePath, varRef);

                        Events.ExecuteOnGetContent(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetContentDefaultImplementation(e, "/{repo}/-/git/contents/{file_path}", uriBuilderLocalVar.Path, repo, filePath, varRef);
                Events.ExecuteOnErrorGetContent(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetContentApiResponse"/>
        /// </summary>
        public partial class GetContentApiResponse : CNBOpenApi.Client.ApiResponse, IGetContentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetContentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetContentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetContentApiResponse(ILogger<GetContentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiContent? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiContent>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.ApiContent? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetHead(ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateGetHead(string repo)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        private void AfterGetHeadDefaultImplementation(IGetHeadApiResponse apiResponseLocalVar, string repo)
        {
            bool suppressDefaultLog = false;
            AfterGetHead(ref suppressDefaultLog, apiResponseLocalVar, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        partial void AfterGetHead(ref bool suppressDefaultLog, IGetHeadApiResponse apiResponseLocalVar, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        private void OnErrorGetHeadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetHead(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        partial void OnErrorGetHead(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo);

        /// <summary>
        /// 获取仓库默认分支 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHeadApiResponse"/>&gt;</returns>
        public async Task<IGetHeadApiResponse?> GetHeadOrDefaultAsync(string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetHeadAsync(repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 获取仓库默认分支 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHeadApiResponse"/>&gt;</returns>
        public async Task<IGetHeadApiResponse> GetHeadAsync(string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetHead(repo);

                FormatGetHead(ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/head"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/head");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetHeadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetHeadApiResponse>();

                        GetHeadApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/head", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetHeadDefaultImplementation(apiResponseLocalVar, repo);

                        Events.ExecuteOnGetHead(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetHeadDefaultImplementation(e, "/{repo}/-/git/head", uriBuilderLocalVar.Path, repo);
                Events.ExecuteOnErrorGetHead(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetHeadApiResponse"/>
        /// </summary>
        public partial class GetHeadApiResponse : CNBOpenApi.Client.ApiResponse, IGetHeadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetHeadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetHeadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetHeadApiResponse(ILogger<GetHeadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.OpenapiHeadRef? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.OpenapiHeadRef>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.OpenapiHeadRef? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTag(ref string repo, ref string tag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <returns></returns>
        private void ValidateGetTag(string repo, string tag)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (tag == null)
                throw new ArgumentNullException(nameof(tag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        private void AfterGetTagDefaultImplementation(IGetTagApiResponse apiResponseLocalVar, string repo, string tag)
        {
            bool suppressDefaultLog = false;
            AfterGetTag(ref suppressDefaultLog, apiResponseLocalVar, repo, tag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        partial void AfterGetTag(ref bool suppressDefaultLog, IGetTagApiResponse apiResponseLocalVar, string repo, string tag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        private void OnErrorGetTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, tag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        partial void OnErrorGetTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag);

        /// <summary>
        /// 查询指定 Tag 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>&gt;</returns>
        public async Task<IGetTagApiResponse?> GetTagOrDefaultAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTagAsync(repo, tag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 Tag 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag name</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>&gt;</returns>
        public async Task<IGetTagApiResponse> GetTagAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTag(repo, tag);

                FormatGetTag(ref repo, ref tag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tags/{tag}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tags/{tag}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btag%7D", Uri.EscapeDataString(tag.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTagApiResponse>();

                        GetTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tags/{tag}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTagDefaultImplementation(apiResponseLocalVar, repo, tag);

                        Events.ExecuteOnGetTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTagDefaultImplementation(e, "/{repo}/-/git/tags/{tag}", uriBuilderLocalVar.Path, repo, tag);
                Events.ExecuteOnErrorGetTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTagApiResponse"/>
        /// </summary>
        public partial class GetTagApiResponse : CNBOpenApi.Client.ApiResponse, IGetTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTagApiResponse(ILogger<GetTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.ApiTag? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.ApiTag>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.ApiTag? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTagAnnotations(ref string repo, ref string tag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <returns></returns>
        private void ValidateGetTagAnnotations(string repo, string tag)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (tag == null)
                throw new ArgumentNullException(nameof(tag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        private void AfterGetTagAnnotationsDefaultImplementation(IGetTagAnnotationsApiResponse apiResponseLocalVar, string repo, string tag)
        {
            bool suppressDefaultLog = false;
            AfterGetTagAnnotations(ref suppressDefaultLog, apiResponseLocalVar, repo, tag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        partial void AfterGetTagAnnotations(ref bool suppressDefaultLog, IGetTagAnnotationsApiResponse apiResponseLocalVar, string repo, string tag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        private void OnErrorGetTagAnnotationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTagAnnotations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, tag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        partial void OnErrorGetTagAnnotations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag);

        /// <summary>
        /// 查询指定 tag 的元数据 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IGetTagAnnotationsApiResponse?> GetTagAnnotationsOrDefaultAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTagAnnotationsAsync(repo, tag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定 tag 的元数据 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IGetTagAnnotationsApiResponse> GetTagAnnotationsAsync(string repo, string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTagAnnotations(repo, tag);

                FormatGetTagAnnotations(ref repo, ref tag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tag-annotations/{tag}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tag-annotations/{tag}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btag%7D", Uri.EscapeDataString(tag.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTagAnnotationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTagAnnotationsApiResponse>();

                        GetTagAnnotationsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tag-annotations/{tag}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTagAnnotationsDefaultImplementation(apiResponseLocalVar, repo, tag);

                        Events.ExecuteOnGetTagAnnotations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTagAnnotationsDefaultImplementation(e, "/{repo}/-/git/tag-annotations/{tag}", uriBuilderLocalVar.Path, repo, tag);
                Events.ExecuteOnErrorGetTagAnnotations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTagAnnotationsApiResponse"/>
        /// </summary>
        public partial class GetTagAnnotationsApiResponse : CNBOpenApi.Client.ApiResponse, IGetTagAnnotationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTagAnnotationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTagAnnotationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTagAnnotationsApiResponse(ILogger<GetTagAnnotationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<WebTagAnnotation>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<WebTagAnnotation>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<WebTagAnnotation>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListBranches(ref string repo, ref Option<int> page, ref Option<int> pageSize);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateListBranches(string repo)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        private void AfterListBranchesDefaultImplementation(IListBranchesApiResponse apiResponseLocalVar, string repo, Option<int> page, Option<int> pageSize)
        {
            bool suppressDefaultLog = false;
            AfterListBranches(ref suppressDefaultLog, apiResponseLocalVar, repo, page, pageSize);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        partial void AfterListBranches(ref bool suppressDefaultLog, IListBranchesApiResponse apiResponseLocalVar, string repo, Option<int> page, Option<int> pageSize);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        private void OnErrorListBranchesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, Option<int> page, Option<int> pageSize)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListBranches(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, page, pageSize);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        partial void OnErrorListBranches(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, Option<int> page, Option<int> pageSize);

        /// <summary>
        /// 查询分支列表 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBranchesApiResponse"/>&gt;</returns>
        public async Task<IListBranchesApiResponse?> ListBranchesOrDefaultAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListBranchesAsync(repo, page, pageSize, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询分支列表 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBranchesApiResponse"/>&gt;</returns>
        public async Task<IListBranchesApiResponse> ListBranchesAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListBranches(repo);

                FormatListBranches(ref repo, ref page, ref pageSize);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/branches"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/branches");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListBranchesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListBranchesApiResponse>();

                        ListBranchesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/branches", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListBranchesDefaultImplementation(apiResponseLocalVar, repo, page, pageSize);

                        Events.ExecuteOnListBranches(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListBranchesDefaultImplementation(e, "/{repo}/-/git/branches", uriBuilderLocalVar.Path, repo, page, pageSize);
                Events.ExecuteOnErrorListBranches(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListBranchesApiResponse"/>
        /// </summary>
        public partial class ListBranchesApiResponse : CNBOpenApi.Client.ApiResponse, IListBranchesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListBranchesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListBranchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBranchesApiResponse(ILogger<ListBranchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ApiBranch>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ApiBranch>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ApiBranch>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListCommits(ref string repo, ref Option<string> sha, ref Option<string> author, ref Option<string> committer, ref Option<string> since, ref Option<string> until, ref Option<int> page, ref Option<int> pageSize);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="author"></param>
        /// <param name="committer"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <returns></returns>
        private void ValidateListCommits(string repo, Option<string> sha, Option<string> author, Option<string> committer, Option<string> since, Option<string> until)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha.IsSet && sha.Value == null)
                throw new ArgumentNullException(nameof(sha));

            if (author.IsSet && author.Value == null)
                throw new ArgumentNullException(nameof(author));

            if (committer.IsSet && committer.Value == null)
                throw new ArgumentNullException(nameof(committer));

            if (since.IsSet && since.Value == null)
                throw new ArgumentNullException(nameof(since));

            if (until.IsSet && until.Value == null)
                throw new ArgumentNullException(nameof(until));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="author"></param>
        /// <param name="committer"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        private void AfterListCommitsDefaultImplementation(IListCommitsApiResponse apiResponseLocalVar, string repo, Option<string> sha, Option<string> author, Option<string> committer, Option<string> since, Option<string> until, Option<int> page, Option<int> pageSize)
        {
            bool suppressDefaultLog = false;
            AfterListCommits(ref suppressDefaultLog, apiResponseLocalVar, repo, sha, author, committer, since, until, page, pageSize);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="author"></param>
        /// <param name="committer"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        partial void AfterListCommits(ref bool suppressDefaultLog, IListCommitsApiResponse apiResponseLocalVar, string repo, Option<string> sha, Option<string> author, Option<string> committer, Option<string> since, Option<string> until, Option<int> page, Option<int> pageSize);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="author"></param>
        /// <param name="committer"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        private void OnErrorListCommitsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, Option<string> sha, Option<string> author, Option<string> committer, Option<string> since, Option<string> until, Option<int> page, Option<int> pageSize)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListCommits(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha, author, committer, since, until, page, pageSize);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="author"></param>
        /// <param name="committer"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        partial void OnErrorListCommits(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, Option<string> sha, Option<string> author, Option<string> committer, Option<string> since, Option<string> until, Option<int> page, Option<int> pageSize);

        /// <summary>
        /// 查询 commit 列表 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha">sha or branch (optional)</param>
        /// <param name="author">commit author pattern (optional)</param>
        /// <param name="committer">commit committer pattern (optional)</param>
        /// <param name="since">commit since (optional)</param>
        /// <param name="until">commit until (optional)</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCommitsApiResponse"/>&gt;</returns>
        public async Task<IListCommitsApiResponse?> ListCommitsOrDefaultAsync(string repo, Option<string> sha = default, Option<string> author = default, Option<string> committer = default, Option<string> since = default, Option<string> until = default, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListCommitsAsync(repo, sha, author, committer, since, until, page, pageSize, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询 commit 列表 访问令牌调用此接口需包含以下权限  repo-code:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">sha or branch (optional)</param>
        /// <param name="author">commit author pattern (optional)</param>
        /// <param name="committer">commit committer pattern (optional)</param>
        /// <param name="since">commit since (optional)</param>
        /// <param name="until">commit until (optional)</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCommitsApiResponse"/>&gt;</returns>
        public async Task<IListCommitsApiResponse> ListCommitsAsync(string repo, Option<string> sha = default, Option<string> author = default, Option<string> committer = default, Option<string> since = default, Option<string> until = default, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListCommits(repo, sha, author, committer, since, until);

                FormatListCommits(ref repo, ref sha, ref author, ref committer, ref since, ref until, ref page, ref pageSize);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commits"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commits");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sha.IsSet)
                        parseQueryStringLocalVar["sha"] = ClientUtils.ParameterToString(sha.Value);

                    if (author.IsSet)
                        parseQueryStringLocalVar["author"] = ClientUtils.ParameterToString(author.Value);

                    if (committer.IsSet)
                        parseQueryStringLocalVar["committer"] = ClientUtils.ParameterToString(committer.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (until.IsSet)
                        parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListCommitsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListCommitsApiResponse>();

                        ListCommitsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commits", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListCommitsDefaultImplementation(apiResponseLocalVar, repo, sha, author, committer, since, until, page, pageSize);

                        Events.ExecuteOnListCommits(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListCommitsDefaultImplementation(e, "/{repo}/-/git/commits", uriBuilderLocalVar.Path, repo, sha, author, committer, since, until, page, pageSize);
                Events.ExecuteOnErrorListCommits(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListCommitsApiResponse"/>
        /// </summary>
        public partial class ListCommitsApiResponse : CNBOpenApi.Client.ApiResponse, IListCommitsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListCommitsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListCommitsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListCommitsApiResponse(ILogger<ListCommitsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ApiCommit>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ApiCommit>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ApiCommit>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListTags(ref string repo, ref Option<int> page, ref Option<int> pageSize);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateListTags(string repo)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        private void AfterListTagsDefaultImplementation(IListTagsApiResponse apiResponseLocalVar, string repo, Option<int> page, Option<int> pageSize)
        {
            bool suppressDefaultLog = false;
            AfterListTags(ref suppressDefaultLog, apiResponseLocalVar, repo, page, pageSize);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        partial void AfterListTags(ref bool suppressDefaultLog, IListTagsApiResponse apiResponseLocalVar, string repo, Option<int> page, Option<int> pageSize);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        private void OnErrorListTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, Option<int> page, Option<int> pageSize)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, page, pageSize);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        partial void OnErrorListTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, Option<int> page, Option<int> pageSize);

        /// <summary>
        /// 查询标签列表 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTagsApiResponse"/>&gt;</returns>
        public async Task<IListTagsApiResponse?> ListTagsOrDefaultAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListTagsAsync(repo, page, pageSize, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询标签列表 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="page">pagination page number (optional, default to 1)</param>
        /// <param name="pageSize">pagination page size (optional, default to 30)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTagsApiResponse"/>&gt;</returns>
        public async Task<IListTagsApiResponse> ListTagsAsync(string repo, Option<int> page = default, Option<int> pageSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListTags(repo);

                FormatListTags(ref repo, ref page, ref pageSize);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tags");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListTagsApiResponse>();

                        ListTagsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListTagsDefaultImplementation(apiResponseLocalVar, repo, page, pageSize);

                        Events.ExecuteOnListTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListTagsDefaultImplementation(e, "/{repo}/-/git/tags", uriBuilderLocalVar.Path, repo, page, pageSize);
                Events.ExecuteOnErrorListTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListTagsApiResponse"/>
        /// </summary>
        public partial class ListTagsApiResponse : CNBOpenApi.Client.ApiResponse, IListTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTagsApiResponse(ILogger<ListTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ApiTag>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ApiTag>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ApiTag>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostCommitAssetUploadConfirmation(ref string repo, ref int sha1, ref string token, ref string assetPath);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="token"></param>
        /// <param name="assetPath"></param>
        /// <returns></returns>
        private void ValidatePostCommitAssetUploadConfirmation(string repo, string token, string assetPath)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (token == null)
                throw new ArgumentNullException(nameof(token));

            if (assetPath == null)
                throw new ArgumentNullException(nameof(assetPath));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="token"></param>
        /// <param name="assetPath"></param>
        private void AfterPostCommitAssetUploadConfirmationDefaultImplementation(IPostCommitAssetUploadConfirmationApiResponse apiResponseLocalVar, string repo, int sha1, string token, string assetPath)
        {
            bool suppressDefaultLog = false;
            AfterPostCommitAssetUploadConfirmation(ref suppressDefaultLog, apiResponseLocalVar, repo, sha1, token, assetPath);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="token"></param>
        /// <param name="assetPath"></param>
        partial void AfterPostCommitAssetUploadConfirmation(ref bool suppressDefaultLog, IPostCommitAssetUploadConfirmationApiResponse apiResponseLocalVar, string repo, int sha1, string token, string assetPath);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="token"></param>
        /// <param name="assetPath"></param>
        private void OnErrorPostCommitAssetUploadConfirmationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, int sha1, string token, string assetPath)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostCommitAssetUploadConfirmation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha1, token, assetPath);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="token"></param>
        /// <param name="assetPath"></param>
        partial void OnErrorPostCommitAssetUploadConfirmation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, int sha1, string token, string assetPath);

        /// <summary>
        /// 确认 Commit asset 上传完成 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="token">upload token</param>
        /// <param name="assetPath">release asset path</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadConfirmationApiResponse"/>&gt;</returns>
        public async Task<IPostCommitAssetUploadConfirmationApiResponse?> PostCommitAssetUploadConfirmationOrDefaultAsync(string repo, int sha1, string token, string assetPath, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostCommitAssetUploadConfirmationAsync(repo, sha1, token, assetPath, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 确认 Commit asset 上传完成 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="token">upload token</param>
        /// <param name="assetPath">release asset path</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadConfirmationApiResponse"/>&gt;</returns>
        public async Task<IPostCommitAssetUploadConfirmationApiResponse> PostCommitAssetUploadConfirmationAsync(string repo, int sha1, string token, string assetPath, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostCommitAssetUploadConfirmation(repo, token, assetPath);

                FormatPostCommitAssetUploadConfirmation(ref repo, ref sha1, ref token, ref assetPath);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-assets/{sha1}/asset-upload-confirmation/{token}/{asset_path}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-assets/{sha1}/asset-upload-confirmation/{token}/{asset_path}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha1%7D", Uri.EscapeDataString(sha1.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btoken%7D", Uri.EscapeDataString(token.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_path%7D", Uri.EscapeDataString(assetPath.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostCommitAssetUploadConfirmationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostCommitAssetUploadConfirmationApiResponse>();

                        PostCommitAssetUploadConfirmationApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-assets/{sha1}/asset-upload-confirmation/{token}/{asset_path}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostCommitAssetUploadConfirmationDefaultImplementation(apiResponseLocalVar, repo, sha1, token, assetPath);

                        Events.ExecuteOnPostCommitAssetUploadConfirmation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostCommitAssetUploadConfirmationDefaultImplementation(e, "/{repo}/-/git/commit-assets/{sha1}/asset-upload-confirmation/{token}/{asset_path}", uriBuilderLocalVar.Path, repo, sha1, token, assetPath);
                Events.ExecuteOnErrorPostCommitAssetUploadConfirmation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostCommitAssetUploadConfirmationApiResponse"/>
        /// </summary>
        public partial class PostCommitAssetUploadConfirmationApiResponse : CNBOpenApi.Client.ApiResponse, IPostCommitAssetUploadConfirmationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostCommitAssetUploadConfirmationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostCommitAssetUploadConfirmationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostCommitAssetUploadConfirmationApiResponse(ILogger<PostCommitAssetUploadConfirmationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostCommitAssetUploadURL(ref string repo, ref int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="createCommitAssetUploadUrlForm"></param>
        /// <returns></returns>
        private void ValidatePostCommitAssetUploadURL(string repo, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (createCommitAssetUploadUrlForm == null)
                throw new ArgumentNullException(nameof(createCommitAssetUploadUrlForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="createCommitAssetUploadUrlForm"></param>
        private void AfterPostCommitAssetUploadURLDefaultImplementation(IPostCommitAssetUploadURLApiResponse apiResponseLocalVar, string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm)
        {
            bool suppressDefaultLog = false;
            AfterPostCommitAssetUploadURL(ref suppressDefaultLog, apiResponseLocalVar, repo, sha1, createCommitAssetUploadUrlForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="createCommitAssetUploadUrlForm"></param>
        partial void AfterPostCommitAssetUploadURL(ref bool suppressDefaultLog, IPostCommitAssetUploadURLApiResponse apiResponseLocalVar, string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="createCommitAssetUploadUrlForm"></param>
        private void OnErrorPostCommitAssetUploadURLDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostCommitAssetUploadURL(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha1, createCommitAssetUploadUrlForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha1"></param>
        /// <param name="createCommitAssetUploadUrlForm"></param>
        partial void OnErrorPostCommitAssetUploadURL(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm);

        /// <summary>
        /// 新增一个 Commit asset 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="createCommitAssetUploadUrlForm">Post Commit Asset Upload URL Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadURLApiResponse"/>&gt;</returns>
        public async Task<IPostCommitAssetUploadURLApiResponse?> PostCommitAssetUploadURLOrDefaultAsync(string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostCommitAssetUploadURLAsync(repo, sha1, createCommitAssetUploadUrlForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 新增一个 Commit asset 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha1">sha</param>
        /// <param name="createCommitAssetUploadUrlForm">Post Commit Asset Upload URL Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostCommitAssetUploadURLApiResponse"/>&gt;</returns>
        public async Task<IPostCommitAssetUploadURLApiResponse> PostCommitAssetUploadURLAsync(string repo, int sha1, OpenapiPostCommitAssetUploadURLForm createCommitAssetUploadUrlForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostCommitAssetUploadURL(repo, createCommitAssetUploadUrlForm);

                FormatPostCommitAssetUploadURL(ref repo, ref sha1, createCommitAssetUploadUrlForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-assets/{sha1}/asset-upload-url"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-assets/{sha1}/asset-upload-url");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha1%7D", Uri.EscapeDataString(sha1.ToString()));

                    httpRequestMessageLocalVar.Content = (createCommitAssetUploadUrlForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createCommitAssetUploadUrlForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostCommitAssetUploadURLApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostCommitAssetUploadURLApiResponse>();

                        PostCommitAssetUploadURLApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-assets/{sha1}/asset-upload-url", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostCommitAssetUploadURLDefaultImplementation(apiResponseLocalVar, repo, sha1, createCommitAssetUploadUrlForm);

                        Events.ExecuteOnPostCommitAssetUploadURL(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostCommitAssetUploadURLDefaultImplementation(e, "/{repo}/-/git/commit-assets/{sha1}/asset-upload-url", uriBuilderLocalVar.Path, repo, sha1, createCommitAssetUploadUrlForm);
                Events.ExecuteOnErrorPostCommitAssetUploadURL(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostCommitAssetUploadURLApiResponse"/>
        /// </summary>
        public partial class PostCommitAssetUploadURLApiResponse : CNBOpenApi.Client.ApiResponse, IPostCommitAssetUploadURLApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostCommitAssetUploadURLApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostCommitAssetUploadURLApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostCommitAssetUploadURLApiResponse(ILogger<PostCommitAssetUploadURLApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.OpenapiCommitAssetUploadURL? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.OpenapiCommitAssetUploadURL>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out CNBOpenApi.Model.OpenapiCommitAssetUploadURL? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPutCommitAnnotations(ref string repo, ref string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="putCommitAnnotationsForm"></param>
        /// <returns></returns>
        private void ValidatePutCommitAnnotations(string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (sha == null)
                throw new ArgumentNullException(nameof(sha));

            if (putCommitAnnotationsForm == null)
                throw new ArgumentNullException(nameof(putCommitAnnotationsForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="putCommitAnnotationsForm"></param>
        private void AfterPutCommitAnnotationsDefaultImplementation(IPutCommitAnnotationsApiResponse apiResponseLocalVar, string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm)
        {
            bool suppressDefaultLog = false;
            AfterPutCommitAnnotations(ref suppressDefaultLog, apiResponseLocalVar, repo, sha, putCommitAnnotationsForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="putCommitAnnotationsForm"></param>
        partial void AfterPutCommitAnnotations(ref bool suppressDefaultLog, IPutCommitAnnotationsApiResponse apiResponseLocalVar, string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="putCommitAnnotationsForm"></param>
        private void OnErrorPutCommitAnnotationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutCommitAnnotations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, sha, putCommitAnnotationsForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="sha"></param>
        /// <param name="putCommitAnnotationsForm"></param>
        partial void OnErrorPutCommitAnnotations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm);

        /// <summary>
        /// 设定指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="putCommitAnnotationsForm">Put Commit Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutCommitAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IPutCommitAnnotationsApiResponse?> PutCommitAnnotationsOrDefaultAsync(string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutCommitAnnotationsAsync(repo, sha, putCommitAnnotationsForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 设定指定 commit 的元数据 访问令牌调用此接口需包含以下权限  repo-code:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="sha">commit hash</param>
        /// <param name="putCommitAnnotationsForm">Put Commit Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutCommitAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IPutCommitAnnotationsApiResponse> PutCommitAnnotationsAsync(string repo, string sha, OpenapiPutCommitAnnotationsForm putCommitAnnotationsForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutCommitAnnotations(repo, sha, putCommitAnnotationsForm);

                FormatPutCommitAnnotations(ref repo, ref sha, putCommitAnnotationsForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/commit-annotations/{sha}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/commit-annotations/{sha}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsha%7D", Uri.EscapeDataString(sha.ToString()));

                    httpRequestMessageLocalVar.Content = (putCommitAnnotationsForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putCommitAnnotationsForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutCommitAnnotationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutCommitAnnotationsApiResponse>();

                        PutCommitAnnotationsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/commit-annotations/{sha}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutCommitAnnotationsDefaultImplementation(apiResponseLocalVar, repo, sha, putCommitAnnotationsForm);

                        Events.ExecuteOnPutCommitAnnotations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutCommitAnnotationsDefaultImplementation(e, "/{repo}/-/git/commit-annotations/{sha}", uriBuilderLocalVar.Path, repo, sha, putCommitAnnotationsForm);
                Events.ExecuteOnErrorPutCommitAnnotations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutCommitAnnotationsApiResponse"/>
        /// </summary>
        public partial class PutCommitAnnotationsApiResponse : CNBOpenApi.Client.ApiResponse, IPutCommitAnnotationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutCommitAnnotationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutCommitAnnotationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutCommitAnnotationsApiResponse(ILogger<PutCommitAnnotationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPutTagAnnotations(ref string repo, ref string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <param name="putTagAnnotationsForm"></param>
        /// <returns></returns>
        private void ValidatePutTagAnnotations(string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm)
        {
            if (repo == null)
                throw new ArgumentNullException(nameof(repo));

            if (tag == null)
                throw new ArgumentNullException(nameof(tag));

            if (putTagAnnotationsForm == null)
                throw new ArgumentNullException(nameof(putTagAnnotationsForm));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <param name="putTagAnnotationsForm"></param>
        private void AfterPutTagAnnotationsDefaultImplementation(IPutTagAnnotationsApiResponse apiResponseLocalVar, string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm)
        {
            bool suppressDefaultLog = false;
            AfterPutTagAnnotations(ref suppressDefaultLog, apiResponseLocalVar, repo, tag, putTagAnnotationsForm);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <param name="putTagAnnotationsForm"></param>
        partial void AfterPutTagAnnotations(ref bool suppressDefaultLog, IPutTagAnnotationsApiResponse apiResponseLocalVar, string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <param name="putTagAnnotationsForm"></param>
        private void OnErrorPutTagAnnotationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutTagAnnotations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, repo, tag, putTagAnnotationsForm);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="repo"></param>
        /// <param name="tag"></param>
        /// <param name="putTagAnnotationsForm"></param>
        partial void OnErrorPutTagAnnotations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm);

        /// <summary>
        /// 设定指定 tag 的元数据 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="putTagAnnotationsForm">Put Tag Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutTagAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IPutTagAnnotationsApiResponse?> PutTagAnnotationsOrDefaultAsync(string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutTagAnnotationsAsync(repo, tag, putTagAnnotationsForm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 设定指定 tag 的元数据 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="repo">repo</param>
        /// <param name="tag">tag</param>
        /// <param name="putTagAnnotationsForm">Put Tag Annotations Form</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutTagAnnotationsApiResponse"/>&gt;</returns>
        public async Task<IPutTagAnnotationsApiResponse> PutTagAnnotationsAsync(string repo, string tag, OpenapiPutTagAnnotationsForm putTagAnnotationsForm, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutTagAnnotations(repo, tag, putTagAnnotationsForm);

                FormatPutTagAnnotations(ref repo, ref tag, putTagAnnotationsForm);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/git/tag-annotations/{tag}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/git/tag-annotations/{tag}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btag%7D", Uri.EscapeDataString(tag.ToString()));

                    httpRequestMessageLocalVar.Content = (putTagAnnotationsForm as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putTagAnnotationsForm, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.api+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutTagAnnotationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutTagAnnotationsApiResponse>();

                        PutTagAnnotationsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/git/tag-annotations/{tag}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutTagAnnotationsDefaultImplementation(apiResponseLocalVar, repo, tag, putTagAnnotationsForm);

                        Events.ExecuteOnPutTagAnnotations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutTagAnnotationsDefaultImplementation(e, "/{repo}/-/git/tag-annotations/{tag}", uriBuilderLocalVar.Path, repo, tag, putTagAnnotationsForm);
                Events.ExecuteOnErrorPutTagAnnotations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutTagAnnotationsApiResponse"/>
        /// </summary>
        public partial class PutTagAnnotationsApiResponse : CNBOpenApi.Client.ApiResponse, IPutTagAnnotationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutTagAnnotationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutTagAnnotationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutTagAnnotationsApiResponse(ILogger<PutTagAnnotationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DieWebError? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DieWebError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out CNBOpenApi.Model.DieWebError? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
