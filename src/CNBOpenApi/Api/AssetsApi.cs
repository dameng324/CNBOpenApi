// <auto-generated>
/*
 * CNB OPENAPI
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: cnb@tencent.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using CNBOpenApi.Client;
using CNBOpenApi.Model;
using System.Diagnostics.CodeAnalysis;

namespace CNBOpenApi.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAssetsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AssetsApiEvents Events { get; }

        /// <summary>
        /// 发起一个获取 commits 附件的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">包含commitSha和文件名，例如 3bba1ce6a8c35ee1264c7449f4f0b512bd751eac/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsApiResponse"/>&gt;</returns>
        Task<IGetCommitAssetsApiResponse> GetCommitAssetsAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 commits 附件的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="fileName">包含commitSha和文件名，例如 3bba1ce6a8c35ee1264c7449f4f0b512bd751eac/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsApiResponse"/>?&gt;</returns>
        Task<IGetCommitAssetsApiResponse?> GetCommitAssetsOrDefaultAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 files 的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesApiResponse"/>&gt;</returns>
        Task<IGetFilesApiResponse> GetFilesAsync(string userIdKey, string randomUUID, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 files 的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesApiResponse"/>?&gt;</returns>
        Task<IGetFilesApiResponse?> GetFilesOrDefaultAsync(string userIdKey, string randomUUID, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 imgs 的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImgsApiResponse"/>&gt;</returns>
        Task<IGetImgsApiResponse> GetImgsAsync(string userIdKey, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 imgs 的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImgsApiResponse"/>?&gt;</returns>
        Task<IGetImgsApiResponse?> GetImgsOrDefaultAsync(string userIdKey, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 latest release 附件的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">文件名，例如 test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestReleasesAssetApiResponse"/>&gt;</returns>
        Task<IGetLatestReleasesAssetApiResponse> GetLatestReleasesAssetAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 latest release 附件的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="fileName">文件名，例如 test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestReleasesAssetApiResponse"/>?&gt;</returns>
        Task<IGetLatestReleasesAssetApiResponse?> GetLatestReleasesAssetOrDefaultAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 logo 的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  group-resource:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">size</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLogosApiResponse"/>&gt;</returns>
        Task<IGetLogosApiResponse> GetLogosAsync(string size, string group, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 logo 的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  group-resource:r
        /// </remarks>
        /// <param name="size">size</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLogosApiResponse"/>?&gt;</returns>
        Task<IGetLogosApiResponse?> GetLogosOrDefaultAsync(string size, string group, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 release 附件的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">包含tag名称和文件名，例如 v1.0/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasesAssetApiResponse"/>&gt;</returns>
        Task<IGetReleasesAssetApiResponse> GetReleasesAssetAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个获取 release 附件的请求，返回内容或者 302 到某个地址
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </remarks>
        /// <param name="fileName">包含tag名称和文件名，例如 v1.0/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasesAssetApiResponse"/>?&gt;</returns>
        Task<IGetReleasesAssetApiResponse?> GetReleasesAssetOrDefaultAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个确认 files 的请求，上传的图片要调用此接口才能生效
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutFilesApiResponse"/>&gt;</returns>
        Task<IPutFilesApiResponse> PutFilesAsync(string userIdKey, string randomUUID, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个确认 files 的请求，上传的图片要调用此接口才能生效
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutFilesApiResponse"/>?&gt;</returns>
        Task<IPutFilesApiResponse?> PutFilesOrDefaultAsync(string userIdKey, string randomUUID, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个确认 imgs 的请求，上传的图片要调用此接口才能生效
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutImgsApiResponse"/>&gt;</returns>
        Task<IPutImgsApiResponse> PutImgsAsync(string userIdKey, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个确认 imgs 的请求，上传的图片要调用此接口才能生效
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutImgsApiResponse"/>?&gt;</returns>
        Task<IPutImgsApiResponse?> PutImgsOrDefaultAsync(string userIdKey, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 确认上传的logo
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutLogosApiResponse"/>&gt;</returns>
        Task<IPutLogosApiResponse> PutLogosAsync(string token, string group, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 确认上传的logo
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </remarks>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutLogosApiResponse"/>?&gt;</returns>
        Task<IPutLogosApiResponse?> PutLogosOrDefaultAsync(string token, string group, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 files（issue，pr 及其评论中文档，压缩包等）的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadFilesApiResponse"/>&gt;</returns>
        Task<IUploadFilesApiResponse> UploadFilesAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 files（issue，pr 及其评论中文档，压缩包等）的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadFilesApiResponse"/>?&gt;</returns>
        Task<IUploadFilesApiResponse?> UploadFilesOrDefaultAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 imgs 的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadImgsApiResponse"/>&gt;</returns>
        Task<IUploadImgsApiResponse> UploadImgsAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 imgs 的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadImgsApiResponse"/>?&gt;</returns>
        Task<IUploadImgsApiResponse?> UploadImgsOrDefaultAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 logo 的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadLogosApiResponse"/>&gt;</returns>
        Task<IUploadLogosApiResponse> UploadLogosAsync(DtoUploadRequestParams request, string group, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 logo 的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </remarks>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadLogosApiResponse"/>?&gt;</returns>
        Task<IUploadLogosApiResponse?> UploadLogosOrDefaultAsync(DtoUploadRequestParams request, string group, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 release 附件的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagName">tag_name</param>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadReleasesApiResponse"/>&gt;</returns>
        Task<IUploadReleasesApiResponse> UploadReleasesAsync(string tagName, DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 发起一个上传 release 附件的请求，返回上传 cos 的 url 和 form 内容
        /// </summary>
        /// <remarks>
        /// 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </remarks>
        /// <param name="tagName">tag_name</param>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadReleasesApiResponse"/>?&gt;</returns>
        Task<IUploadReleasesApiResponse?> UploadReleasesOrDefaultAsync(string tagName, DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetCommitAssetsApiResponse"/>
    /// </summary>
    public interface IGetCommitAssetsApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesApiResponse"/>
    /// </summary>
    public interface IGetFilesApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetImgsApiResponse"/>
    /// </summary>
    public interface IGetImgsApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetLatestReleasesAssetApiResponse"/>
    /// </summary>
    public interface IGetLatestReleasesAssetApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetLogosApiResponse"/>
    /// </summary>
    public interface IGetLogosApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetReleasesAssetApiResponse"/>
    /// </summary>
    public interface IGetReleasesAssetApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }
    }

    /// <summary>
    /// The <see cref="IPutFilesApiResponse"/>
    /// </summary>
    public interface IPutFilesApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPutImgsApiResponse"/>
    /// </summary>
    public interface IPutImgsApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPutLogosApiResponse"/>
    /// </summary>
    public interface IPutLogosApiResponse : CNBOpenApi.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUploadFilesApiResponse"/>
    /// </summary>
    public interface IUploadFilesApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.DtoUploadAssetsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUploadImgsApiResponse"/>
    /// </summary>
    public interface IUploadImgsApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.DtoUploadAssetsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUploadLogosApiResponse"/>
    /// </summary>
    public interface IUploadLogosApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.DtoUploadAssetsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUploadReleasesApiResponse"/>
    /// </summary>
    public interface IUploadReleasesApiResponse : CNBOpenApi.Client.IApiResponse, IOk<CNBOpenApi.Model.DtoUploadAssetsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AssetsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommitAssets;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommitAssets;

        internal void ExecuteOnGetCommitAssets(AssetsApi.GetCommitAssetsApiResponse apiResponse)
        {
            OnGetCommitAssets?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommitAssets(Exception exception)
        {
            OnErrorGetCommitAssets?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFiles;

        internal void ExecuteOnGetFiles(AssetsApi.GetFilesApiResponse apiResponse)
        {
            OnGetFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFiles(Exception exception)
        {
            OnErrorGetFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetImgs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetImgs;

        internal void ExecuteOnGetImgs(AssetsApi.GetImgsApiResponse apiResponse)
        {
            OnGetImgs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetImgs(Exception exception)
        {
            OnErrorGetImgs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetLatestReleasesAsset;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetLatestReleasesAsset;

        internal void ExecuteOnGetLatestReleasesAsset(AssetsApi.GetLatestReleasesAssetApiResponse apiResponse)
        {
            OnGetLatestReleasesAsset?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLatestReleasesAsset(Exception exception)
        {
            OnErrorGetLatestReleasesAsset?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetLogos;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetLogos;

        internal void ExecuteOnGetLogos(AssetsApi.GetLogosApiResponse apiResponse)
        {
            OnGetLogos?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLogos(Exception exception)
        {
            OnErrorGetLogos?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetReleasesAsset;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetReleasesAsset;

        internal void ExecuteOnGetReleasesAsset(AssetsApi.GetReleasesAssetApiResponse apiResponse)
        {
            OnGetReleasesAsset?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetReleasesAsset(Exception exception)
        {
            OnErrorGetReleasesAsset?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserAvatar;


        internal void ExecuteOnErrorGetUserAvatar(Exception exception)
        {
            OnErrorGetUserAvatar?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutFiles;

        internal void ExecuteOnPutFiles(AssetsApi.PutFilesApiResponse apiResponse)
        {
            OnPutFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutFiles(Exception exception)
        {
            OnErrorPutFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutImgs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutImgs;

        internal void ExecuteOnPutImgs(AssetsApi.PutImgsApiResponse apiResponse)
        {
            OnPutImgs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutImgs(Exception exception)
        {
            OnErrorPutImgs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPutLogos;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPutLogos;

        internal void ExecuteOnPutLogos(AssetsApi.PutLogosApiResponse apiResponse)
        {
            OnPutLogos?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPutLogos(Exception exception)
        {
            OnErrorPutLogos?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUploadFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUploadFiles;

        internal void ExecuteOnUploadFiles(AssetsApi.UploadFilesApiResponse apiResponse)
        {
            OnUploadFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadFiles(Exception exception)
        {
            OnErrorUploadFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUploadImgs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUploadImgs;

        internal void ExecuteOnUploadImgs(AssetsApi.UploadImgsApiResponse apiResponse)
        {
            OnUploadImgs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadImgs(Exception exception)
        {
            OnErrorUploadImgs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUploadLogos;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUploadLogos;

        internal void ExecuteOnUploadLogos(AssetsApi.UploadLogosApiResponse apiResponse)
        {
            OnUploadLogos?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadLogos(Exception exception)
        {
            OnErrorUploadLogos?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUploadReleases;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUploadReleases;

        internal void ExecuteOnUploadReleases(AssetsApi.UploadReleasesApiResponse apiResponse)
        {
            OnUploadReleases?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadReleases(Exception exception)
        {
            OnErrorUploadReleases?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AssetsApi : IAssetsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AssetsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AssetsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AssetsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AssetsApi(ILogger<AssetsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AssetsApiEvents assetsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AssetsApi>();
            HttpClient = httpClient;
            Events = assetsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatGetCommitAssets(ref string fileName, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateGetCommitAssets(string fileName, string repo)
        {
            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void AfterGetCommitAssetsDefaultImplementation(IGetCommitAssetsApiResponse apiResponseLocalVar, string fileName, string repo)
        {
            bool suppressDefaultLog = false;
            AfterGetCommitAssets(ref suppressDefaultLog, apiResponseLocalVar, fileName, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void AfterGetCommitAssets(ref bool suppressDefaultLog, IGetCommitAssetsApiResponse apiResponseLocalVar, string fileName, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void OnErrorGetCommitAssetsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fileName, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommitAssets(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileName, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void OnErrorGetCommitAssets(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fileName, string repo);

        /// <summary>
        /// 发起一个获取 commits 附件的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="fileName">包含commitSha和文件名，例如 3bba1ce6a8c35ee1264c7449f4f0b512bd751eac/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAssetsApiResponse?> GetCommitAssetsOrDefaultAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommitAssetsAsync(fileName, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个获取 commits 附件的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">包含commitSha和文件名，例如 3bba1ce6a8c35ee1264c7449f4f0b512bd751eac/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommitAssetsApiResponse"/>&gt;</returns>
        public async Task<IGetCommitAssetsApiResponse> GetCommitAssetsAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCommitAssets(fileName, repo);

                FormatGetCommitAssets(ref fileName, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/commit-assets/download/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/commit-assets/download/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommitAssetsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommitAssetsApiResponse>();

                        GetCommitAssetsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/commit-assets/download/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommitAssetsDefaultImplementation(apiResponseLocalVar, fileName, repo);

                        Events.ExecuteOnGetCommitAssets(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommitAssetsDefaultImplementation(e, "/{repo}/-/commit-assets/download/{fileName}", uriBuilderLocalVar.Path, fileName, repo);
                Events.ExecuteOnErrorGetCommitAssets(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommitAssetsApiResponse"/>
        /// </summary>
        public partial class GetCommitAssetsApiResponse : CNBOpenApi.Client.ApiResponse, IGetCommitAssetsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommitAssetsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommitAssetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommitAssetsApiResponse(ILogger<GetCommitAssetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFiles(ref string userIdKey, ref string randomUUID, ref string fileName, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateGetFiles(string userIdKey, string randomUUID, string fileName, string repo)
        {
            if (userIdKey == null)
                throw new ArgumentNullException(nameof(userIdKey));

            if (randomUUID == null)
                throw new ArgumentNullException(nameof(randomUUID));

            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void AfterGetFilesDefaultImplementation(IGetFilesApiResponse apiResponseLocalVar, string userIdKey, string randomUUID, string fileName, string repo)
        {
            bool suppressDefaultLog = false;
            AfterGetFiles(ref suppressDefaultLog, apiResponseLocalVar, userIdKey, randomUUID, fileName, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void AfterGetFiles(ref bool suppressDefaultLog, IGetFilesApiResponse apiResponseLocalVar, string userIdKey, string randomUUID, string fileName, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void OnErrorGetFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string randomUUID, string fileName, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userIdKey, randomUUID, fileName, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void OnErrorGetFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string randomUUID, string fileName, string repo);

        /// <summary>
        /// 发起一个获取 files 的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesApiResponse"/>&gt;</returns>
        public async Task<IGetFilesApiResponse?> GetFilesOrDefaultAsync(string userIdKey, string randomUUID, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesAsync(userIdKey, randomUUID, fileName, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个获取 files 的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesApiResponse"/>&gt;</returns>
        public async Task<IGetFilesApiResponse> GetFilesAsync(string userIdKey, string randomUUID, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFiles(userIdKey, randomUUID, fileName, repo);

                FormatGetFiles(ref userIdKey, ref randomUUID, ref fileName, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserIdKey%7D", Uri.EscapeDataString(userIdKey.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrandomUUID%7D", Uri.EscapeDataString(randomUUID.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesApiResponse>();

                        GetFilesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetFilesDefaultImplementation(apiResponseLocalVar, userIdKey, randomUUID, fileName, repo);

                        Events.ExecuteOnGetFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesDefaultImplementation(e, "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}", uriBuilderLocalVar.Path, userIdKey, randomUUID, fileName, repo);
                Events.ExecuteOnErrorGetFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesApiResponse"/>
        /// </summary>
        public partial class GetFilesApiResponse : CNBOpenApi.Client.ApiResponse, IGetFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesApiResponse(ILogger<GetFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetImgs(ref string userIdKey, ref string fileName, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateGetImgs(string userIdKey, string fileName, string repo)
        {
            if (userIdKey == null)
                throw new ArgumentNullException(nameof(userIdKey));

            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void AfterGetImgsDefaultImplementation(IGetImgsApiResponse apiResponseLocalVar, string userIdKey, string fileName, string repo)
        {
            bool suppressDefaultLog = false;
            AfterGetImgs(ref suppressDefaultLog, apiResponseLocalVar, userIdKey, fileName, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void AfterGetImgs(ref bool suppressDefaultLog, IGetImgsApiResponse apiResponseLocalVar, string userIdKey, string fileName, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void OnErrorGetImgsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string fileName, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetImgs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userIdKey, fileName, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void OnErrorGetImgs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string fileName, string repo);

        /// <summary>
        /// 发起一个获取 imgs 的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImgsApiResponse"/>&gt;</returns>
        public async Task<IGetImgsApiResponse?> GetImgsOrDefaultAsync(string userIdKey, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetImgsAsync(userIdKey, fileName, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个获取 imgs 的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImgsApiResponse"/>&gt;</returns>
        public async Task<IGetImgsApiResponse> GetImgsAsync(string userIdKey, string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetImgs(userIdKey, fileName, repo);

                FormatGetImgs(ref userIdKey, ref fileName, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/imgs/{userIdKey}/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/imgs/{userIdKey}/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserIdKey%7D", Uri.EscapeDataString(userIdKey.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetImgsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetImgsApiResponse>();

                        GetImgsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/imgs/{userIdKey}/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetImgsDefaultImplementation(apiResponseLocalVar, userIdKey, fileName, repo);

                        Events.ExecuteOnGetImgs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetImgsDefaultImplementation(e, "/{repo}/-/imgs/{userIdKey}/{fileName}", uriBuilderLocalVar.Path, userIdKey, fileName, repo);
                Events.ExecuteOnErrorGetImgs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetImgsApiResponse"/>
        /// </summary>
        public partial class GetImgsApiResponse : CNBOpenApi.Client.ApiResponse, IGetImgsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetImgsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetImgsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetImgsApiResponse(ILogger<GetImgsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLatestReleasesAsset(ref string fileName, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateGetLatestReleasesAsset(string fileName, string repo)
        {
            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void AfterGetLatestReleasesAssetDefaultImplementation(IGetLatestReleasesAssetApiResponse apiResponseLocalVar, string fileName, string repo)
        {
            bool suppressDefaultLog = false;
            AfterGetLatestReleasesAsset(ref suppressDefaultLog, apiResponseLocalVar, fileName, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void AfterGetLatestReleasesAsset(ref bool suppressDefaultLog, IGetLatestReleasesAssetApiResponse apiResponseLocalVar, string fileName, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void OnErrorGetLatestReleasesAssetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fileName, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLatestReleasesAsset(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileName, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void OnErrorGetLatestReleasesAsset(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fileName, string repo);

        /// <summary>
        /// 发起一个获取 latest release 附件的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="fileName">文件名，例如 test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestReleasesAssetApiResponse"/>&gt;</returns>
        public async Task<IGetLatestReleasesAssetApiResponse?> GetLatestReleasesAssetOrDefaultAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLatestReleasesAssetAsync(fileName, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个获取 latest release 附件的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">文件名，例如 test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestReleasesAssetApiResponse"/>&gt;</returns>
        public async Task<IGetLatestReleasesAssetApiResponse> GetLatestReleasesAssetAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetLatestReleasesAsset(fileName, repo);

                FormatGetLatestReleasesAsset(ref fileName, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/releases/latest/download/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/releases/latest/download/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetLatestReleasesAssetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLatestReleasesAssetApiResponse>();

                        GetLatestReleasesAssetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/releases/latest/download/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetLatestReleasesAssetDefaultImplementation(apiResponseLocalVar, fileName, repo);

                        Events.ExecuteOnGetLatestReleasesAsset(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLatestReleasesAssetDefaultImplementation(e, "/{repo}/-/releases/latest/download/{fileName}", uriBuilderLocalVar.Path, fileName, repo);
                Events.ExecuteOnErrorGetLatestReleasesAsset(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLatestReleasesAssetApiResponse"/>
        /// </summary>
        public partial class GetLatestReleasesAssetApiResponse : CNBOpenApi.Client.ApiResponse, IGetLatestReleasesAssetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLatestReleasesAssetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLatestReleasesAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLatestReleasesAssetApiResponse(ILogger<GetLatestReleasesAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLogos(ref string size, ref string group);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="size"></param>
        /// <param name="group"></param>
        /// <returns></returns>
        private void ValidateGetLogos(string size, string group)
        {
            if (size == null)
                throw new ArgumentNullException(nameof(size));

            if (group == null)
                throw new ArgumentNullException(nameof(group));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="group"></param>
        private void AfterGetLogosDefaultImplementation(IGetLogosApiResponse apiResponseLocalVar, string size, string group)
        {
            bool suppressDefaultLog = false;
            AfterGetLogos(ref suppressDefaultLog, apiResponseLocalVar, size, group);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="group"></param>
        partial void AfterGetLogos(ref bool suppressDefaultLog, IGetLogosApiResponse apiResponseLocalVar, string size, string group);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="group"></param>
        private void OnErrorGetLogosDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string size, string group)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLogos(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, size, group);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="group"></param>
        partial void OnErrorGetLogos(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string size, string group);

        /// <summary>
        /// 发起一个获取 logo 的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  group-resource:r
        /// </summary>
        /// <param name="size">size</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLogosApiResponse"/>&gt;</returns>
        public async Task<IGetLogosApiResponse?> GetLogosOrDefaultAsync(string size, string group, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLogosAsync(size, group, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个获取 logo 的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  group-resource:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">size</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLogosApiResponse"/>&gt;</returns>
        public async Task<IGetLogosApiResponse> GetLogosAsync(string size, string group, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetLogos(size, group);

                FormatGetLogos(ref size, ref group);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{group}/-/logos/{size}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{group}/-/logos/{size}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsize%7D", Uri.EscapeDataString(size.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bgroup%7D", Uri.EscapeDataString(group.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetLogosApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLogosApiResponse>();

                        GetLogosApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{group}/-/logos/{size}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetLogosDefaultImplementation(apiResponseLocalVar, size, group);

                        Events.ExecuteOnGetLogos(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLogosDefaultImplementation(e, "/{group}/-/logos/{size}", uriBuilderLocalVar.Path, size, group);
                Events.ExecuteOnErrorGetLogos(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLogosApiResponse"/>
        /// </summary>
        public partial class GetLogosApiResponse : CNBOpenApi.Client.ApiResponse, IGetLogosApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLogosApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLogosApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLogosApiResponse(ILogger<GetLogosApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetReleasesAsset(ref string fileName, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateGetReleasesAsset(string fileName, string repo)
        {
            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void AfterGetReleasesAssetDefaultImplementation(IGetReleasesAssetApiResponse apiResponseLocalVar, string fileName, string repo)
        {
            bool suppressDefaultLog = false;
            AfterGetReleasesAsset(ref suppressDefaultLog, apiResponseLocalVar, fileName, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void AfterGetReleasesAsset(ref bool suppressDefaultLog, IGetReleasesAssetApiResponse apiResponseLocalVar, string fileName, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        private void OnErrorGetReleasesAssetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fileName, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetReleasesAsset(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileName, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileName"></param>
        /// <param name="repo"></param>
        partial void OnErrorGetReleasesAsset(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fileName, string repo);

        /// <summary>
        /// 发起一个获取 release 附件的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <param name="fileName">包含tag名称和文件名，例如 v1.0/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasesAssetApiResponse"/>&gt;</returns>
        public async Task<IGetReleasesAssetApiResponse?> GetReleasesAssetOrDefaultAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetReleasesAssetAsync(fileName, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个获取 release 附件的请求，返回内容或者 302 到某个地址 访问令牌调用此接口需包含以下权限  repo-contents:r
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">包含tag名称和文件名，例如 v1.0/test.png</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasesAssetApiResponse"/>&gt;</returns>
        public async Task<IGetReleasesAssetApiResponse> GetReleasesAssetAsync(string fileName, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetReleasesAsset(fileName, repo);

                FormatGetReleasesAsset(ref fileName, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/releases/download/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/releases/download/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetReleasesAssetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetReleasesAssetApiResponse>();

                        GetReleasesAssetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/releases/download/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetReleasesAssetDefaultImplementation(apiResponseLocalVar, fileName, repo);

                        Events.ExecuteOnGetReleasesAsset(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetReleasesAssetDefaultImplementation(e, "/{repo}/-/releases/download/{fileName}", uriBuilderLocalVar.Path, fileName, repo);
                Events.ExecuteOnErrorGetReleasesAsset(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetReleasesAssetApiResponse"/>
        /// </summary>
        public partial class GetReleasesAssetApiResponse : CNBOpenApi.Client.ApiResponse, IGetReleasesAssetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetReleasesAssetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetReleasesAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetReleasesAssetApiResponse(ILogger<GetReleasesAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserAvatar(ref string size, ref string username);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="size"></param>
        /// <param name="username"></param>
        /// <returns></returns>
        private void ValidateGetUserAvatar(string size, string username)
        {
            if (size == null)
                throw new ArgumentNullException(nameof(size));

            if (username == null)
                throw new ArgumentNullException(nameof(username));
        }

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="username"></param>
        private void OnErrorGetUserAvatarDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string size, string username)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetUserAvatar(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, size, username);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="username"></param>
        partial void OnErrorGetUserAvatar(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string size, string username);

        partial void FormatPutFiles(ref string userIdKey, ref string randomUUID, ref string fileName, ref string token, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidatePutFiles(string userIdKey, string randomUUID, string fileName, string token, string repo)
        {
            if (userIdKey == null)
                throw new ArgumentNullException(nameof(userIdKey));

            if (randomUUID == null)
                throw new ArgumentNullException(nameof(randomUUID));

            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (token == null)
                throw new ArgumentNullException(nameof(token));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        private void AfterPutFilesDefaultImplementation(IPutFilesApiResponse apiResponseLocalVar, string userIdKey, string randomUUID, string fileName, string token, string repo)
        {
            bool suppressDefaultLog = false;
            AfterPutFiles(ref suppressDefaultLog, apiResponseLocalVar, userIdKey, randomUUID, fileName, token, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        partial void AfterPutFiles(ref bool suppressDefaultLog, IPutFilesApiResponse apiResponseLocalVar, string userIdKey, string randomUUID, string fileName, string token, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        private void OnErrorPutFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string randomUUID, string fileName, string token, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userIdKey, randomUUID, fileName, token, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="randomUUID"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        partial void OnErrorPutFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string randomUUID, string fileName, string token, string repo);

        /// <summary>
        /// 发起一个确认 files 的请求，上传的图片要调用此接口才能生效 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutFilesApiResponse"/>&gt;</returns>
        public async Task<IPutFilesApiResponse?> PutFilesOrDefaultAsync(string userIdKey, string randomUUID, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutFilesAsync(userIdKey, randomUUID, fileName, token, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个确认 files 的请求，上传的图片要调用此接口才能生效 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="randomUUID">random_uuid</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutFilesApiResponse"/>&gt;</returns>
        public async Task<IPutFilesApiResponse> PutFilesAsync(string userIdKey, string randomUUID, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutFiles(userIdKey, randomUUID, fileName, token, repo);

                FormatPutFiles(ref userIdKey, ref randomUUID, ref fileName, ref token, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserIdKey%7D", Uri.EscapeDataString(userIdKey.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrandomUUID%7D", Uri.EscapeDataString(randomUUID.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutFilesApiResponse>();

                        PutFilesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutFilesDefaultImplementation(apiResponseLocalVar, userIdKey, randomUUID, fileName, token, repo);

                        Events.ExecuteOnPutFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutFilesDefaultImplementation(e, "/{repo}/-/files/{userIdKey}/{randomUUID}/{fileName}", uriBuilderLocalVar.Path, userIdKey, randomUUID, fileName, token, repo);
                Events.ExecuteOnErrorPutFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutFilesApiResponse"/>
        /// </summary>
        public partial class PutFilesApiResponse : CNBOpenApi.Client.ApiResponse, IPutFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutFilesApiResponse(ILogger<PutFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPutImgs(ref string userIdKey, ref string fileName, ref string token, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidatePutImgs(string userIdKey, string fileName, string token, string repo)
        {
            if (userIdKey == null)
                throw new ArgumentNullException(nameof(userIdKey));

            if (fileName == null)
                throw new ArgumentNullException(nameof(fileName));

            if (token == null)
                throw new ArgumentNullException(nameof(token));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        private void AfterPutImgsDefaultImplementation(IPutImgsApiResponse apiResponseLocalVar, string userIdKey, string fileName, string token, string repo)
        {
            bool suppressDefaultLog = false;
            AfterPutImgs(ref suppressDefaultLog, apiResponseLocalVar, userIdKey, fileName, token, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        partial void AfterPutImgs(ref bool suppressDefaultLog, IPutImgsApiResponse apiResponseLocalVar, string userIdKey, string fileName, string token, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        private void OnErrorPutImgsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string fileName, string token, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutImgs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userIdKey, fileName, token, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userIdKey"></param>
        /// <param name="fileName"></param>
        /// <param name="token"></param>
        /// <param name="repo"></param>
        partial void OnErrorPutImgs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userIdKey, string fileName, string token, string repo);

        /// <summary>
        /// 发起一个确认 imgs 的请求，上传的图片要调用此接口才能生效 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutImgsApiResponse"/>&gt;</returns>
        public async Task<IPutImgsApiResponse?> PutImgsOrDefaultAsync(string userIdKey, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutImgsAsync(userIdKey, fileName, token, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个确认 imgs 的请求，上传的图片要调用此接口才能生效 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userIdKey">user_id_key</param>
        /// <param name="fileName">file_name</param>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="repo">Repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutImgsApiResponse"/>&gt;</returns>
        public async Task<IPutImgsApiResponse> PutImgsAsync(string userIdKey, string fileName, string token, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutImgs(userIdKey, fileName, token, repo);

                FormatPutImgs(ref userIdKey, ref fileName, ref token, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/imgs/{userIdKey}/{fileName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/imgs/{userIdKey}/{fileName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserIdKey%7D", Uri.EscapeDataString(userIdKey.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfileName%7D", Uri.EscapeDataString(fileName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutImgsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutImgsApiResponse>();

                        PutImgsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/imgs/{userIdKey}/{fileName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutImgsDefaultImplementation(apiResponseLocalVar, userIdKey, fileName, token, repo);

                        Events.ExecuteOnPutImgs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutImgsDefaultImplementation(e, "/{repo}/-/imgs/{userIdKey}/{fileName}", uriBuilderLocalVar.Path, userIdKey, fileName, token, repo);
                Events.ExecuteOnErrorPutImgs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutImgsApiResponse"/>
        /// </summary>
        public partial class PutImgsApiResponse : CNBOpenApi.Client.ApiResponse, IPutImgsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutImgsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutImgsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutImgsApiResponse(ILogger<PutImgsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPutLogos(ref string token, ref string group);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="token"></param>
        /// <param name="group"></param>
        /// <returns></returns>
        private void ValidatePutLogos(string token, string group)
        {
            if (token == null)
                throw new ArgumentNullException(nameof(token));

            if (group == null)
                throw new ArgumentNullException(nameof(group));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="group"></param>
        private void AfterPutLogosDefaultImplementation(IPutLogosApiResponse apiResponseLocalVar, string token, string group)
        {
            bool suppressDefaultLog = false;
            AfterPutLogos(ref suppressDefaultLog, apiResponseLocalVar, token, group);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="group"></param>
        partial void AfterPutLogos(ref bool suppressDefaultLog, IPutLogosApiResponse apiResponseLocalVar, string token, string group);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="group"></param>
        private void OnErrorPutLogosDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string token, string group)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPutLogos(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, token, group);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="group"></param>
        partial void OnErrorPutLogos(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string token, string group);

        /// <summary>
        /// 确认上传的logo 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </summary>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutLogosApiResponse"/>&gt;</returns>
        public async Task<IPutLogosApiResponse?> PutLogosOrDefaultAsync(string token, string group, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PutLogosAsync(token, group, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 确认上传的logo 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">获取 uploadurl 时返回的token</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPutLogosApiResponse"/>&gt;</returns>
        public async Task<IPutLogosApiResponse> PutLogosAsync(string token, string group, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePutLogos(token, group);

                FormatPutLogos(ref token, ref group);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{group}/-/logos"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{group}/-/logos");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bgroup%7D", Uri.EscapeDataString(group.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PutLogosApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PutLogosApiResponse>();

                        PutLogosApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{group}/-/logos", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPutLogosDefaultImplementation(apiResponseLocalVar, token, group);

                        Events.ExecuteOnPutLogos(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPutLogosDefaultImplementation(e, "/{group}/-/logos", uriBuilderLocalVar.Path, token, group);
                Events.ExecuteOnErrorPutLogos(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PutLogosApiResponse"/>
        /// </summary>
        public partial class PutLogosApiResponse : CNBOpenApi.Client.ApiResponse, IPutLogosApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PutLogosApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PutLogosApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PutLogosApiResponse(ILogger<PutLogosApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadFiles(DtoUploadRequestParams request, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateUploadFiles(DtoUploadRequestParams request, string repo)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        private void AfterUploadFilesDefaultImplementation(IUploadFilesApiResponse apiResponseLocalVar, DtoUploadRequestParams request, string repo)
        {
            bool suppressDefaultLog = false;
            AfterUploadFiles(ref suppressDefaultLog, apiResponseLocalVar, request, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        partial void AfterUploadFiles(ref bool suppressDefaultLog, IUploadFilesApiResponse apiResponseLocalVar, DtoUploadRequestParams request, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        private void OnErrorUploadFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DtoUploadRequestParams request, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, request, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        partial void OnErrorUploadFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DtoUploadRequestParams request, string repo);

        /// <summary>
        /// 发起一个上传 files（issue，pr 及其评论中文档，压缩包等）的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadFilesApiResponse"/>&gt;</returns>
        public async Task<IUploadFilesApiResponse?> UploadFilesOrDefaultAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadFilesAsync(request, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个上传 files（issue，pr 及其评论中文档，压缩包等）的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadFilesApiResponse"/>&gt;</returns>
        public async Task<IUploadFilesApiResponse> UploadFilesAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadFiles(request, repo);

                FormatUploadFiles(request, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/upload/files"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/upload/files");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (request as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(request, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.web+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UploadFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadFilesApiResponse>();

                        UploadFilesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/upload/files", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadFilesDefaultImplementation(apiResponseLocalVar, request, repo);

                        Events.ExecuteOnUploadFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadFilesDefaultImplementation(e, "/{repo}/-/upload/files", uriBuilderLocalVar.Path, request, repo);
                Events.ExecuteOnErrorUploadFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadFilesApiResponse"/>
        /// </summary>
        public partial class UploadFilesApiResponse : CNBOpenApi.Client.ApiResponse, IUploadFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadFilesApiResponse(ILogger<UploadFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DtoUploadAssetsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DtoUploadAssetsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.DtoUploadAssetsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadImgs(DtoUploadRequestParams request, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateUploadImgs(DtoUploadRequestParams request, string repo)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        private void AfterUploadImgsDefaultImplementation(IUploadImgsApiResponse apiResponseLocalVar, DtoUploadRequestParams request, string repo)
        {
            bool suppressDefaultLog = false;
            AfterUploadImgs(ref suppressDefaultLog, apiResponseLocalVar, request, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        partial void AfterUploadImgs(ref bool suppressDefaultLog, IUploadImgsApiResponse apiResponseLocalVar, DtoUploadRequestParams request, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        private void OnErrorUploadImgsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DtoUploadRequestParams request, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadImgs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, request, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        partial void OnErrorUploadImgs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DtoUploadRequestParams request, string repo);

        /// <summary>
        /// 发起一个上传 imgs 的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadImgsApiResponse"/>&gt;</returns>
        public async Task<IUploadImgsApiResponse?> UploadImgsOrDefaultAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadImgsAsync(request, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个上传 imgs 的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadImgsApiResponse"/>&gt;</returns>
        public async Task<IUploadImgsApiResponse> UploadImgsAsync(DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadImgs(request, repo);

                FormatUploadImgs(request, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/upload/imgs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/upload/imgs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (request as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(request, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.web+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UploadImgsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadImgsApiResponse>();

                        UploadImgsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/upload/imgs", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadImgsDefaultImplementation(apiResponseLocalVar, request, repo);

                        Events.ExecuteOnUploadImgs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadImgsDefaultImplementation(e, "/{repo}/-/upload/imgs", uriBuilderLocalVar.Path, request, repo);
                Events.ExecuteOnErrorUploadImgs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadImgsApiResponse"/>
        /// </summary>
        public partial class UploadImgsApiResponse : CNBOpenApi.Client.ApiResponse, IUploadImgsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadImgsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadImgsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadImgsApiResponse(ILogger<UploadImgsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DtoUploadAssetsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DtoUploadAssetsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.DtoUploadAssetsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadLogos(DtoUploadRequestParams request, ref string group);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="request"></param>
        /// <param name="group"></param>
        /// <returns></returns>
        private void ValidateUploadLogos(DtoUploadRequestParams request, string group)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            if (group == null)
                throw new ArgumentNullException(nameof(group));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="group"></param>
        private void AfterUploadLogosDefaultImplementation(IUploadLogosApiResponse apiResponseLocalVar, DtoUploadRequestParams request, string group)
        {
            bool suppressDefaultLog = false;
            AfterUploadLogos(ref suppressDefaultLog, apiResponseLocalVar, request, group);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="group"></param>
        partial void AfterUploadLogos(ref bool suppressDefaultLog, IUploadLogosApiResponse apiResponseLocalVar, DtoUploadRequestParams request, string group);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="group"></param>
        private void OnErrorUploadLogosDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DtoUploadRequestParams request, string group)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadLogos(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, request, group);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="request"></param>
        /// <param name="group"></param>
        partial void OnErrorUploadLogos(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DtoUploadRequestParams request, string group);

        /// <summary>
        /// 发起一个上传 logo 的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </summary>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadLogosApiResponse"/>&gt;</returns>
        public async Task<IUploadLogosApiResponse?> UploadLogosOrDefaultAsync(DtoUploadRequestParams request, string group, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadLogosAsync(request, group, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个上传 logo 的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  group-manage:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="group">group</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadLogosApiResponse"/>&gt;</returns>
        public async Task<IUploadLogosApiResponse> UploadLogosAsync(DtoUploadRequestParams request, string group, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadLogos(request, group);

                FormatUploadLogos(request, ref group);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{group}/-/upload/logos"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{group}/-/upload/logos");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bgroup%7D", Uri.EscapeDataString(group.ToString()));

                    httpRequestMessageLocalVar.Content = (request as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(request, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.web+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UploadLogosApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadLogosApiResponse>();

                        UploadLogosApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{group}/-/upload/logos", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadLogosDefaultImplementation(apiResponseLocalVar, request, group);

                        Events.ExecuteOnUploadLogos(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadLogosDefaultImplementation(e, "/{group}/-/upload/logos", uriBuilderLocalVar.Path, request, group);
                Events.ExecuteOnErrorUploadLogos(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadLogosApiResponse"/>
        /// </summary>
        public partial class UploadLogosApiResponse : CNBOpenApi.Client.ApiResponse, IUploadLogosApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadLogosApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadLogosApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadLogosApiResponse(ILogger<UploadLogosApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DtoUploadAssetsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DtoUploadAssetsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.DtoUploadAssetsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadReleases(ref string tagName, DtoUploadRequestParams request, ref string repo);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tagName"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        /// <returns></returns>
        private void ValidateUploadReleases(string tagName, DtoUploadRequestParams request, string repo)
        {
            if (tagName == null)
                throw new ArgumentNullException(nameof(tagName));

            if (request == null)
                throw new ArgumentNullException(nameof(request));

            if (repo == null)
                throw new ArgumentNullException(nameof(repo));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagName"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        private void AfterUploadReleasesDefaultImplementation(IUploadReleasesApiResponse apiResponseLocalVar, string tagName, DtoUploadRequestParams request, string repo)
        {
            bool suppressDefaultLog = false;
            AfterUploadReleases(ref suppressDefaultLog, apiResponseLocalVar, tagName, request, repo);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagName"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        partial void AfterUploadReleases(ref bool suppressDefaultLog, IUploadReleasesApiResponse apiResponseLocalVar, string tagName, DtoUploadRequestParams request, string repo);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tagName"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        private void OnErrorUploadReleasesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tagName, DtoUploadRequestParams request, string repo)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadReleases(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tagName, request, repo);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tagName"></param>
        /// <param name="request"></param>
        /// <param name="repo"></param>
        partial void OnErrorUploadReleases(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tagName, DtoUploadRequestParams request, string repo);

        /// <summary>
        /// 发起一个上传 release 附件的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <param name="tagName">tag_name</param>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadReleasesApiResponse"/>&gt;</returns>
        public async Task<IUploadReleasesApiResponse?> UploadReleasesOrDefaultAsync(string tagName, DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadReleasesAsync(tagName, request, repo, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 发起一个上传 release 附件的请求，返回上传 cos 的 url 和 form 内容 访问令牌调用此接口需包含以下权限  repo-contents:rw
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagName">tag_name</param>
        /// <param name="request">UploadRequestParams</param>
        /// <param name="repo">repo</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadReleasesApiResponse"/>&gt;</returns>
        public async Task<IUploadReleasesApiResponse> UploadReleasesAsync(string tagName, DtoUploadRequestParams request, string repo, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadReleases(tagName, request, repo);

                FormatUploadReleases(ref tagName, request, ref repo);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/{repo}/-/upload/releases/{tagName}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/{repo}/-/upload/releases/{tagName}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagName%7D", Uri.EscapeDataString(tagName.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brepo%7D", Uri.EscapeDataString(repo.ToString()));

                    httpRequestMessageLocalVar.Content = (request as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(request, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/vnd.cnb.web+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UploadReleasesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadReleasesApiResponse>();

                        UploadReleasesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/{repo}/-/upload/releases/{tagName}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadReleasesDefaultImplementation(apiResponseLocalVar, tagName, request, repo);

                        Events.ExecuteOnUploadReleases(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadReleasesDefaultImplementation(e, "/{repo}/-/upload/releases/{tagName}", uriBuilderLocalVar.Path, tagName, request, repo);
                Events.ExecuteOnErrorUploadReleases(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadReleasesApiResponse"/>
        /// </summary>
        public partial class UploadReleasesApiResponse : CNBOpenApi.Client.ApiResponse, IUploadReleasesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadReleasesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadReleasesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadReleasesApiResponse(ILogger<UploadReleasesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public CNBOpenApi.Model.DtoUploadAssetsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<CNBOpenApi.Model.DtoUploadAssetsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out CNBOpenApi.Model.DtoUploadAssetsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
