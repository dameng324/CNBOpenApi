// <auto-generated>
/*
 * CNB OPENAPI
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: cnb@tencent.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using CNBOpenApi.Client;

namespace CNBOpenApi.Model
{
    /// <summary>
    /// ChartMetadata
    /// </summary>
    public partial class ChartMetadata : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChartMetadata" /> class.
        /// </summary>
        /// <param name="annotations">Annotations are additional mappings uninterpreted by Helm, made available for inspection by other applications.</param>
        /// <param name="apiVersion">The API Version of this chart. Required.</param>
        /// <param name="appVersion">The version of the application enclosed inside of this chart.</param>
        /// <param name="condition">The condition to check to enable chart</param>
        /// <param name="dependencies">Dependencies are a list of dependencies for a chart.</param>
        /// <param name="deprecated">Whether or not this chart is deprecated</param>
        /// <param name="description">A one-sentence description of the chart</param>
        /// <param name="home">The URL to a relevant project page, git repo, or contact person</param>
        /// <param name="icon">The URL to an icon file.</param>
        /// <param name="keywords">A list of string keywords</param>
        /// <param name="kubeVersion">KubeVersion is a SemVer constraint specifying the version of Kubernetes required.</param>
        /// <param name="maintainers">A list of name and URL/email address combinations for the maintainer(s)</param>
        /// <param name="name">The name of the chart. Required.</param>
        /// <param name="sources">Source is the URL to the source code of this chart</param>
        /// <param name="tags">The tags to check to enable chart</param>
        /// <param name="type">Specifies the chart type: application or library</param>
        /// <param name="varVersion">A SemVer 2 conformant version string of the chart. Required.</param>
        [JsonConstructor]
        public ChartMetadata(Option<Dictionary<string, string>?> annotations = default, Option<string?> apiVersion = default, Option<string?> appVersion = default, Option<string?> condition = default, Option<List<ChartDependency>?> dependencies = default, Option<bool?> deprecated = default, Option<string?> description = default, Option<string?> home = default, Option<string?> icon = default, Option<List<string>?> keywords = default, Option<string?> kubeVersion = default, Option<List<ChartMaintainer>?> maintainers = default, Option<string?> name = default, Option<List<string>?> sources = default, Option<string?> tags = default, Option<string?> type = default, Option<string?> varVersion = default)
        {
            AnnotationsOption = annotations;
            ApiVersionOption = apiVersion;
            AppVersionOption = appVersion;
            ConditionOption = condition;
            DependenciesOption = dependencies;
            DeprecatedOption = deprecated;
            DescriptionOption = description;
            HomeOption = home;
            IconOption = icon;
            KeywordsOption = keywords;
            KubeVersionOption = kubeVersion;
            MaintainersOption = maintainers;
            NameOption = name;
            SourcesOption = sources;
            TagsOption = tags;
            TypeOption = type;
            VarVersionOption = varVersion;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Annotations
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, string>?> AnnotationsOption { get; private set; }

        /// <summary>
        /// Annotations are additional mappings uninterpreted by Helm, made available for inspection by other applications.
        /// </summary>
        /// <value>Annotations are additional mappings uninterpreted by Helm, made available for inspection by other applications.</value>
        [JsonPropertyName("annotations")]
        public Dictionary<string, string>? Annotations { get { return this.AnnotationsOption; } set { this.AnnotationsOption = new(value); } }

        /// <summary>
        /// Used to track the state of ApiVersion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ApiVersionOption { get; private set; }

        /// <summary>
        /// The API Version of this chart. Required.
        /// </summary>
        /// <value>The API Version of this chart. Required.</value>
        [JsonPropertyName("apiVersion")]
        public string? ApiVersion { get { return this.ApiVersionOption; } set { this.ApiVersionOption = new(value); } }

        /// <summary>
        /// Used to track the state of AppVersion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AppVersionOption { get; private set; }

        /// <summary>
        /// The version of the application enclosed inside of this chart.
        /// </summary>
        /// <value>The version of the application enclosed inside of this chart.</value>
        [JsonPropertyName("appVersion")]
        public string? AppVersion { get { return this.AppVersionOption; } set { this.AppVersionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Condition
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ConditionOption { get; private set; }

        /// <summary>
        /// The condition to check to enable chart
        /// </summary>
        /// <value>The condition to check to enable chart</value>
        [JsonPropertyName("condition")]
        public string? Condition { get { return this.ConditionOption; } set { this.ConditionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Dependencies
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<ChartDependency>?> DependenciesOption { get; private set; }

        /// <summary>
        /// Dependencies are a list of dependencies for a chart.
        /// </summary>
        /// <value>Dependencies are a list of dependencies for a chart.</value>
        [JsonPropertyName("dependencies")]
        public List<ChartDependency>? Dependencies { get { return this.DependenciesOption; } set { this.DependenciesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Deprecated
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DeprecatedOption { get; private set; }

        /// <summary>
        /// Whether or not this chart is deprecated
        /// </summary>
        /// <value>Whether or not this chart is deprecated</value>
        [JsonPropertyName("deprecated")]
        public bool? Deprecated { get { return this.DeprecatedOption; } set { this.DeprecatedOption = new(value); } }

        /// <summary>
        /// Used to track the state of Description
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DescriptionOption { get; private set; }

        /// <summary>
        /// A one-sentence description of the chart
        /// </summary>
        /// <value>A one-sentence description of the chart</value>
        [JsonPropertyName("description")]
        public string? Description { get { return this.DescriptionOption; } set { this.DescriptionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Home
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> HomeOption { get; private set; }

        /// <summary>
        /// The URL to a relevant project page, git repo, or contact person
        /// </summary>
        /// <value>The URL to a relevant project page, git repo, or contact person</value>
        [JsonPropertyName("home")]
        public string? Home { get { return this.HomeOption; } set { this.HomeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Icon
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IconOption { get; private set; }

        /// <summary>
        /// The URL to an icon file.
        /// </summary>
        /// <value>The URL to an icon file.</value>
        [JsonPropertyName("icon")]
        public string? Icon { get { return this.IconOption; } set { this.IconOption = new(value); } }

        /// <summary>
        /// Used to track the state of Keywords
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> KeywordsOption { get; private set; }

        /// <summary>
        /// A list of string keywords
        /// </summary>
        /// <value>A list of string keywords</value>
        [JsonPropertyName("keywords")]
        public List<string>? Keywords { get { return this.KeywordsOption; } set { this.KeywordsOption = new(value); } }

        /// <summary>
        /// Used to track the state of KubeVersion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> KubeVersionOption { get; private set; }

        /// <summary>
        /// KubeVersion is a SemVer constraint specifying the version of Kubernetes required.
        /// </summary>
        /// <value>KubeVersion is a SemVer constraint specifying the version of Kubernetes required.</value>
        [JsonPropertyName("kubeVersion")]
        public string? KubeVersion { get { return this.KubeVersionOption; } set { this.KubeVersionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Maintainers
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<ChartMaintainer>?> MaintainersOption { get; private set; }

        /// <summary>
        /// A list of name and URL/email address combinations for the maintainer(s)
        /// </summary>
        /// <value>A list of name and URL/email address combinations for the maintainer(s)</value>
        [JsonPropertyName("maintainers")]
        public List<ChartMaintainer>? Maintainers { get { return this.MaintainersOption; } set { this.MaintainersOption = new(value); } }

        /// <summary>
        /// Used to track the state of Name
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> NameOption { get; private set; }

        /// <summary>
        /// The name of the chart. Required.
        /// </summary>
        /// <value>The name of the chart. Required.</value>
        [JsonPropertyName("name")]
        public string? Name { get { return this.NameOption; } set { this.NameOption = new(value); } }

        /// <summary>
        /// Used to track the state of Sources
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> SourcesOption { get; private set; }

        /// <summary>
        /// Source is the URL to the source code of this chart
        /// </summary>
        /// <value>Source is the URL to the source code of this chart</value>
        [JsonPropertyName("sources")]
        public List<string>? Sources { get { return this.SourcesOption; } set { this.SourcesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Tags
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TagsOption { get; private set; }

        /// <summary>
        /// The tags to check to enable chart
        /// </summary>
        /// <value>The tags to check to enable chart</value>
        [JsonPropertyName("tags")]
        public string? Tags { get { return this.TagsOption; } set { this.TagsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Type
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TypeOption { get; private set; }

        /// <summary>
        /// Specifies the chart type: application or library
        /// </summary>
        /// <value>Specifies the chart type: application or library</value>
        [JsonPropertyName("type")]
        public string? Type { get { return this.TypeOption; } set { this.TypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of VarVersion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> VarVersionOption { get; private set; }

        /// <summary>
        /// A SemVer 2 conformant version string of the chart. Required.
        /// </summary>
        /// <value>A SemVer 2 conformant version string of the chart. Required.</value>
        [JsonPropertyName("version")]
        public string? VarVersion { get { return this.VarVersionOption; } set { this.VarVersionOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ChartMetadata {\n");
            sb.Append("  Annotations: ").Append(Annotations).Append("\n");
            sb.Append("  ApiVersion: ").Append(ApiVersion).Append("\n");
            sb.Append("  AppVersion: ").Append(AppVersion).Append("\n");
            sb.Append("  Condition: ").Append(Condition).Append("\n");
            sb.Append("  Dependencies: ").Append(Dependencies).Append("\n");
            sb.Append("  Deprecated: ").Append(Deprecated).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Home: ").Append(Home).Append("\n");
            sb.Append("  Icon: ").Append(Icon).Append("\n");
            sb.Append("  Keywords: ").Append(Keywords).Append("\n");
            sb.Append("  KubeVersion: ").Append(KubeVersion).Append("\n");
            sb.Append("  Maintainers: ").Append(Maintainers).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Sources: ").Append(Sources).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  VarVersion: ").Append(VarVersion).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ChartMetadata" />
    /// </summary>
    public class ChartMetadataJsonConverter : JsonConverter<ChartMetadata>
    {
        /// <summary>
        /// Deserializes json to <see cref="ChartMetadata" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ChartMetadata Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Dictionary<string, string>?> annotations = default;
            Option<string?> apiVersion = default;
            Option<string?> appVersion = default;
            Option<string?> condition = default;
            Option<List<ChartDependency>?> dependencies = default;
            Option<bool?> deprecated = default;
            Option<string?> description = default;
            Option<string?> home = default;
            Option<string?> icon = default;
            Option<List<string>?> keywords = default;
            Option<string?> kubeVersion = default;
            Option<List<ChartMaintainer>?> maintainers = default;
            Option<string?> name = default;
            Option<List<string>?> sources = default;
            Option<string?> tags = default;
            Option<string?> type = default;
            Option<string?> varVersion = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "annotations":
                            annotations = new Option<Dictionary<string, string>?>(JsonSerializer.Deserialize<Dictionary<string, string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "apiVersion":
                            apiVersion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "appVersion":
                            appVersion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "condition":
                            condition = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "dependencies":
                            dependencies = new Option<List<ChartDependency>?>(JsonSerializer.Deserialize<List<ChartDependency>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "deprecated":
                            deprecated = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "description":
                            description = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "home":
                            home = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "icon":
                            icon = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "keywords":
                            keywords = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "kubeVersion":
                            kubeVersion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "maintainers":
                            maintainers = new Option<List<ChartMaintainer>?>(JsonSerializer.Deserialize<List<ChartMaintainer>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "name":
                            name = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "sources":
                            sources = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "tags":
                            tags = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "type":
                            type = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "version":
                            varVersion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (annotations.IsSet && annotations.Value == null)
                throw new ArgumentNullException(nameof(annotations), "Property is not nullable for class ChartMetadata.");

            if (apiVersion.IsSet && apiVersion.Value == null)
                throw new ArgumentNullException(nameof(apiVersion), "Property is not nullable for class ChartMetadata.");

            if (appVersion.IsSet && appVersion.Value == null)
                throw new ArgumentNullException(nameof(appVersion), "Property is not nullable for class ChartMetadata.");

            if (condition.IsSet && condition.Value == null)
                throw new ArgumentNullException(nameof(condition), "Property is not nullable for class ChartMetadata.");

            if (dependencies.IsSet && dependencies.Value == null)
                throw new ArgumentNullException(nameof(dependencies), "Property is not nullable for class ChartMetadata.");

            if (deprecated.IsSet && deprecated.Value == null)
                throw new ArgumentNullException(nameof(deprecated), "Property is not nullable for class ChartMetadata.");

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description), "Property is not nullable for class ChartMetadata.");

            if (home.IsSet && home.Value == null)
                throw new ArgumentNullException(nameof(home), "Property is not nullable for class ChartMetadata.");

            if (icon.IsSet && icon.Value == null)
                throw new ArgumentNullException(nameof(icon), "Property is not nullable for class ChartMetadata.");

            if (keywords.IsSet && keywords.Value == null)
                throw new ArgumentNullException(nameof(keywords), "Property is not nullable for class ChartMetadata.");

            if (kubeVersion.IsSet && kubeVersion.Value == null)
                throw new ArgumentNullException(nameof(kubeVersion), "Property is not nullable for class ChartMetadata.");

            if (maintainers.IsSet && maintainers.Value == null)
                throw new ArgumentNullException(nameof(maintainers), "Property is not nullable for class ChartMetadata.");

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name), "Property is not nullable for class ChartMetadata.");

            if (sources.IsSet && sources.Value == null)
                throw new ArgumentNullException(nameof(sources), "Property is not nullable for class ChartMetadata.");

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags), "Property is not nullable for class ChartMetadata.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class ChartMetadata.");

            if (varVersion.IsSet && varVersion.Value == null)
                throw new ArgumentNullException(nameof(varVersion), "Property is not nullable for class ChartMetadata.");

            return new ChartMetadata(annotations, apiVersion, appVersion, condition, dependencies, deprecated, description, home, icon, keywords, kubeVersion, maintainers, name, sources, tags, type, varVersion);
        }

        /// <summary>
        /// Serializes a <see cref="ChartMetadata" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="chartMetadata"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ChartMetadata chartMetadata, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, chartMetadata, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ChartMetadata" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="chartMetadata"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ChartMetadata chartMetadata, JsonSerializerOptions jsonSerializerOptions)
        {
            if (chartMetadata.AnnotationsOption.IsSet && chartMetadata.Annotations == null)
                throw new ArgumentNullException(nameof(chartMetadata.Annotations), "Property is required for class ChartMetadata.");

            if (chartMetadata.ApiVersionOption.IsSet && chartMetadata.ApiVersion == null)
                throw new ArgumentNullException(nameof(chartMetadata.ApiVersion), "Property is required for class ChartMetadata.");

            if (chartMetadata.AppVersionOption.IsSet && chartMetadata.AppVersion == null)
                throw new ArgumentNullException(nameof(chartMetadata.AppVersion), "Property is required for class ChartMetadata.");

            if (chartMetadata.ConditionOption.IsSet && chartMetadata.Condition == null)
                throw new ArgumentNullException(nameof(chartMetadata.Condition), "Property is required for class ChartMetadata.");

            if (chartMetadata.DependenciesOption.IsSet && chartMetadata.Dependencies == null)
                throw new ArgumentNullException(nameof(chartMetadata.Dependencies), "Property is required for class ChartMetadata.");

            if (chartMetadata.DescriptionOption.IsSet && chartMetadata.Description == null)
                throw new ArgumentNullException(nameof(chartMetadata.Description), "Property is required for class ChartMetadata.");

            if (chartMetadata.HomeOption.IsSet && chartMetadata.Home == null)
                throw new ArgumentNullException(nameof(chartMetadata.Home), "Property is required for class ChartMetadata.");

            if (chartMetadata.IconOption.IsSet && chartMetadata.Icon == null)
                throw new ArgumentNullException(nameof(chartMetadata.Icon), "Property is required for class ChartMetadata.");

            if (chartMetadata.KeywordsOption.IsSet && chartMetadata.Keywords == null)
                throw new ArgumentNullException(nameof(chartMetadata.Keywords), "Property is required for class ChartMetadata.");

            if (chartMetadata.KubeVersionOption.IsSet && chartMetadata.KubeVersion == null)
                throw new ArgumentNullException(nameof(chartMetadata.KubeVersion), "Property is required for class ChartMetadata.");

            if (chartMetadata.MaintainersOption.IsSet && chartMetadata.Maintainers == null)
                throw new ArgumentNullException(nameof(chartMetadata.Maintainers), "Property is required for class ChartMetadata.");

            if (chartMetadata.NameOption.IsSet && chartMetadata.Name == null)
                throw new ArgumentNullException(nameof(chartMetadata.Name), "Property is required for class ChartMetadata.");

            if (chartMetadata.SourcesOption.IsSet && chartMetadata.Sources == null)
                throw new ArgumentNullException(nameof(chartMetadata.Sources), "Property is required for class ChartMetadata.");

            if (chartMetadata.TagsOption.IsSet && chartMetadata.Tags == null)
                throw new ArgumentNullException(nameof(chartMetadata.Tags), "Property is required for class ChartMetadata.");

            if (chartMetadata.TypeOption.IsSet && chartMetadata.Type == null)
                throw new ArgumentNullException(nameof(chartMetadata.Type), "Property is required for class ChartMetadata.");

            if (chartMetadata.VarVersionOption.IsSet && chartMetadata.VarVersion == null)
                throw new ArgumentNullException(nameof(chartMetadata.VarVersion), "Property is required for class ChartMetadata.");

            if (chartMetadata.AnnotationsOption.IsSet)
            {
                writer.WritePropertyName("annotations");
                JsonSerializer.Serialize(writer, chartMetadata.Annotations, jsonSerializerOptions);
            }
            if (chartMetadata.ApiVersionOption.IsSet)
                writer.WriteString("apiVersion", chartMetadata.ApiVersion);

            if (chartMetadata.AppVersionOption.IsSet)
                writer.WriteString("appVersion", chartMetadata.AppVersion);

            if (chartMetadata.ConditionOption.IsSet)
                writer.WriteString("condition", chartMetadata.Condition);

            if (chartMetadata.DependenciesOption.IsSet)
            {
                writer.WritePropertyName("dependencies");
                JsonSerializer.Serialize(writer, chartMetadata.Dependencies, jsonSerializerOptions);
            }
            if (chartMetadata.DeprecatedOption.IsSet)
                writer.WriteBoolean("deprecated", chartMetadata.DeprecatedOption.Value!.Value);

            if (chartMetadata.DescriptionOption.IsSet)
                writer.WriteString("description", chartMetadata.Description);

            if (chartMetadata.HomeOption.IsSet)
                writer.WriteString("home", chartMetadata.Home);

            if (chartMetadata.IconOption.IsSet)
                writer.WriteString("icon", chartMetadata.Icon);

            if (chartMetadata.KeywordsOption.IsSet)
            {
                writer.WritePropertyName("keywords");
                JsonSerializer.Serialize(writer, chartMetadata.Keywords, jsonSerializerOptions);
            }
            if (chartMetadata.KubeVersionOption.IsSet)
                writer.WriteString("kubeVersion", chartMetadata.KubeVersion);

            if (chartMetadata.MaintainersOption.IsSet)
            {
                writer.WritePropertyName("maintainers");
                JsonSerializer.Serialize(writer, chartMetadata.Maintainers, jsonSerializerOptions);
            }
            if (chartMetadata.NameOption.IsSet)
                writer.WriteString("name", chartMetadata.Name);

            if (chartMetadata.SourcesOption.IsSet)
            {
                writer.WritePropertyName("sources");
                JsonSerializer.Serialize(writer, chartMetadata.Sources, jsonSerializerOptions);
            }
            if (chartMetadata.TagsOption.IsSet)
                writer.WriteString("tags", chartMetadata.Tags);

            if (chartMetadata.TypeOption.IsSet)
                writer.WriteString("type", chartMetadata.Type);

            if (chartMetadata.VarVersionOption.IsSet)
                writer.WriteString("version", chartMetadata.VarVersion);
        }
    }
}
